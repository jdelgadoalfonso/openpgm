--- if.c	2010-05-29 17:36:46.000000000 +0800
+++ if.c89	2010-08-05 13:19:04.000000000 +0800
@@ -102,8 +102,13 @@
 		char b[IF_NAMESIZE * 2 + 3];
 
 		pgm_if_indextoname (i, rname);
+#ifdef _MSC_VER
+		_snprintf_s (b, sizeof(b), _TRUNCATE, "%s (%s)",
+			ifa->ifa_name ? ifa->ifa_name : "(null)", rname);
+#else
 		sprintf (b, "%s (%s)",
 			ifa->ifa_name ? ifa->ifa_name : "(null)", rname);
+#endif
 
 		if (NULL == ifa->ifa_addr ||
 		     (ifa->ifa_addr->sa_family != AF_INET && 
@@ -121,6 +126,7 @@
 			continue;
 		}
 
+		{
 		char s[INET6_ADDRSTRLEN];
 		getnameinfo (ifa->ifa_addr, pgm_sockaddr_len(ifa->ifa_addr),
 			     s, sizeof(s),
@@ -137,6 +143,7 @@
 			ifa->ifa_flags & IFF_BROADCAST ? "YES" : "NO ",
 			ifa->ifa_flags & IFF_MULTICAST ? "YES" : "NO "
 			);
+		}
 	}
 
 	pgm_freeifaddrs (ifap);
@@ -190,9 +197,12 @@
 		 pgm_inet_ntop (AF_INET6, netmask, snetmask, sizeof(snetmask)));
 #endif
 
-	for (unsigned i = 0; i < 16; i++)
+	{
+	unsigned i;
+	for (i = 0; i < 16; i++)
 		if ((addr->s6_addr[i] & netmask->s6_addr[i]) != (netaddr->s6_addr[i] & netmask->s6_addr[i]))
 			return FALSE;
+	}
 	return TRUE;
 }
 
@@ -254,8 +264,12 @@
 	{
 		const size_t ifnamelen = strlen(ifname);
 		if (']' == ifname[ ifnamelen - 1 ]) {
+#ifdef _MSC_VER
+			strncpy_s (literal, sizeof(literal), ifname + 1, ifnamelen - 2);
+#else
 			strncpy (literal, ifname + 1, ifnamelen - 2);
 			literal[ ifnamelen - 2 ] = 0;
+#endif
 			family = AF_INET6;		/* force IPv6 evaluation */
 			check_inet6_network = TRUE;	/* may be a network IP or CIDR block */
 			check_addr = TRUE;		/* cannot be not a name */
@@ -278,11 +292,13 @@
 				     ifname ? "\"" : "", ifname ? ifname : "(null)", ifname ? "\"" : "");
 			return FALSE;
 		}
+		{
 		struct sockaddr_in s4;
 		memset (&s4, 0, sizeof(s4));
 		s4.sin_family = AF_INET;
 		s4.sin_addr.s_addr = htonl (in_addr.s_addr);
 		memcpy (&addr, &s4, sizeof(s4));
+		}
 
 		check_inet_network = TRUE;
 		check_addr = TRUE;
@@ -297,11 +313,13 @@
 				     ifname ? "\"" : "", ifname ? ifname : "(null)", ifname ? "\"" : "");
 			return FALSE;
 		}
+		{
 		struct sockaddr_in6 s6;
 		memset (&s6, 0, sizeof(s6));
 		s6.sin6_family = AF_INET6;
 		s6.sin6_addr = in6_addr;
 		memcpy (&addr, &s6, sizeof(s6));
+		}
 
 		check_inet6_network = TRUE;
 		check_addr = TRUE;
@@ -310,12 +328,13 @@
 /* numeric host with scope id */
 	if (!check_addr)
 	{
-		struct addrinfo hints = {
-			.ai_family	= family,
-			.ai_socktype	= SOCK_STREAM,				/* not really, SOCK_RAW */
-			.ai_protocol	= IPPROTO_TCP,				/* not really, IPPROTO_PGM */
-			.ai_flags	= AI_ADDRCONFIG | AI_NUMERICHOST	/* AI_V4MAPPED is unhelpful */
-		}, *res;
+		struct addrinfo hints, *res;
+		memset (&hints, 0, sizeof(hints));
+		hints.ai_family		= family;
+		hints.ai_socktype	= SOCK_STREAM;				/* not really, SOCK_RAW */
+		hints.ai_protocol	= IPPROTO_TCP;				/* not really, IPPROTO_PGM */
+		hints.ai_flags		= AI_ADDRCONFIG | AI_NUMERICHOST;	/* AI_V4MAPPED is unhelpful */
+		{
 		const int eai = getaddrinfo (ifname, NULL, &hints, &res);
 		switch (eai) {
 		case 0:
@@ -361,6 +380,7 @@
 				     gai_strerror (eai));
 			return FALSE;
 		}
+		}
 	}
 
 #ifndef _WIN32
@@ -441,13 +461,13 @@
 /* hostname lookup with potential DNS delay or error */
 	if (!check_addr)
 	{
-		struct addrinfo hints = {
-			.ai_family	= family,
-			.ai_socktype	= SOCK_STREAM,		/* not really, SOCK_RAW */
-			.ai_protocol	= IPPROTO_TCP,		/* not really, IPPROTO_PGM */
-			.ai_flags	= AI_ADDRCONFIG,	/* AI_V4MAPPED is unhelpful */
-		}, *res;
-
+		struct addrinfo hints, *res;
+		memset (&hints, 0, sizeof(hints));
+		hints.ai_family		= family;
+		hints.ai_socktype	= SOCK_STREAM;		/* not really, SOCK_RAW */
+		hints.ai_protocol	= IPPROTO_TCP;		/* not really, IPPROTO_PGM */
+		hints.ai_flags		= AI_ADDRCONFIG;	/* AI_V4MAPPED is unhelpful */
+		{
 		const int eai = getaddrinfo (ifname, NULL, &hints, &res);
 		switch (eai) {
 		case 0:
@@ -493,6 +513,7 @@
 				     gai_strerror (eai), eai);
 			return FALSE;
 		}
+		}
 	}
 
 /* iterate through interface list and match device name, ip or net address */
@@ -525,6 +546,7 @@
 			continue;
 		}
 
+		{
 		const unsigned ifindex = pgm_if_nametoindex (ifa->ifa_addr->sa_family, ifa->ifa_name);
 		pgm_assert (0 != ifindex);
 
@@ -532,7 +554,11 @@
 		if (check_addr &&
 		    (0 == pgm_sockaddr_cmp (ifa->ifa_addr, (const struct sockaddr*)&addr)))
 		{
+#ifdef _MSC_VER
+			strcpy_s (ir->ir_name, IF_NAMESIZE, ifa->ifa_name);
+#else
 			strcpy (ir->ir_name, ifa->ifa_name);
+#endif
 			ir->ir_flags = ifa->ifa_flags;
 			if (ir->ir_flags & IFF_LOOPBACK)
 				pgm_warn (_("Interface %s reports as a loopback device."), ir->ir_name);
@@ -548,10 +574,15 @@
 		if (check_inet_network &&
 		    AF_INET == ifa->ifa_addr->sa_family)
 		{
-			const struct in_addr ifaddr  = { .s_addr = ntohl (((struct sockaddr_in*)ifa->ifa_addr)->sin_addr.s_addr) };
-			const struct in_addr netmask = { .s_addr = ntohl (((struct sockaddr_in*)ifa->ifa_netmask)->sin_addr.s_addr) };
+			struct in_addr ifaddr, netmask;
+			ifaddr.s_addr = ntohl (((struct sockaddr_in*)ifa->ifa_addr)->sin_addr.s_addr);
+			netmask.s_addr = ntohl (((struct sockaddr_in*)ifa->ifa_netmask)->sin_addr.s_addr);
 			if (is_in_net (&ifaddr, &in_addr, &netmask)) {
+#ifdef _MSC_VER
+				strcpy_s (ir->ir_name, IF_NAMESIZE, ifa->ifa_name);
+#else
 				strcpy (ir->ir_name, ifa->ifa_name);
+#endif
 				ir->ir_flags = ifa->ifa_flags;
 				if (ir->ir_flags & IFF_LOOPBACK) {
 					pgm_warn (_("Skipping matching loopback network device %s."), ir->ir_name);
@@ -573,7 +604,11 @@
 			const struct in6_addr ifaddr = ((struct sockaddr_in6*)ifa->ifa_addr)->sin6_addr;
 			const struct in6_addr netmask = ((struct sockaddr_in6*)ifa->ifa_netmask)->sin6_addr;
 			if (is_in_net6 (&ifaddr, &in6_addr, &netmask)) {
+#ifdef _MSC_VER
+				strcpy_s (ir->ir_name, IF_NAMESIZE, ifa->ifa_name);
+#else
 				strcpy (ir->ir_name, ifa->ifa_name);
+#endif
 				ir->ir_flags = ifa->ifa_flags;
 				if (ir->ir_flags & IFF_LOOPBACK) {
 					pgm_warn (_("Skipping matching loopback network device %s."), ir->ir_name);
@@ -614,11 +649,15 @@
 			}
 
 			ir->ir_interface = ifindex;
+#ifdef _MSC_VER
+			strcpy_s (ir->ir_name, IF_NAMESIZE, ifa->ifa_name);
+#else
 			strcpy (ir->ir_name, ifa->ifa_name);
+#endif
 			memcpy (&ir->ir_addr, ifa->ifa_addr, pgm_sockaddr_len (ifa->ifa_addr));
 			continue;
 		}
-
+		}
 	}
 
 	if (0 == interface_matches) {
@@ -681,8 +720,12 @@
 		const size_t grouplen = strlen(group);
 		if (']' == group[ grouplen - 1 ]) {
 			char literal[1024];
+#ifdef _MSC_VER
+			strncpy_s (literal, sizeof(literal), group + 1, grouplen - 2);
+#else
 			strncpy (literal, group + 1, grouplen - 2);
 			literal[ grouplen - 2 ] = 0;
+#endif
 			if (pgm_inet_pton (AF_INET6, literal, &((struct sockaddr_in6*)addr)->sin6_addr) &&
 			    IN6_IS_ADDR_MULTICAST(&((struct sockaddr_in6*)addr)->sin6_addr))
 			{
@@ -784,13 +827,14 @@
 #endif /* _WIN32 */
 
 /* lookup group through name service */
-	struct addrinfo hints = {
-		.ai_family	= family,
-		.ai_socktype	= SOCK_STREAM,		/* not really, SOCK_RAW */
-		.ai_protocol	= IPPROTO_TCP,		/* not really, IPPROTO_PGM */
-		.ai_flags	= AI_ADDRCONFIG,	/* AI_V4MAPPED is unhelpful */
-	}, *res;
-
+	{
+	struct addrinfo hints, *res;
+	memset (&hints, 0, sizeof(hints));
+	hints.ai_family		= family;
+	hints.ai_socktype	= SOCK_STREAM;		/* not really, SOCK_RAW */
+	hints.ai_protocol	= IPPROTO_TCP;		/* not really, IPPROTO_PGM */
+	hints.ai_flags		= AI_ADDRCONFIG;	/* AI_V4MAPPED is unhelpful */
+	{
 	const int eai = getaddrinfo (group, NULL, &hints, &res);
 	if (0 != eai) {
 		pgm_set_error (error,
@@ -816,6 +860,8 @@
 		     group ? "\"" : "", group ? group : "(null)", group ? "\"" : "");
 	freeaddrinfo (res);
 	return FALSE;
+	}
+	}
 }
 
 /* parse an interface entity from a network parameter.
@@ -869,6 +915,7 @@
 	}
 
 /* check interface name length limit */
+	{
 	char** tokens = pgm_strsplit (entity, ",", 10);
 	int j = 0;
 	while (tokens && tokens[j])
@@ -903,6 +950,7 @@
 
 	pgm_strfreev (tokens);
 	*interface_list = source_list;
+	}
 	return TRUE;
 }
 
@@ -945,6 +993,7 @@
 		(const void*)recv_list,
 		(const void*)error);
 
+	{
 	struct group_source_req* recv_gsr;
 	struct interface_req* primary_interface = (struct interface_req*)pgm_memdup ((*interface_list)->data, sizeof(struct interface_req));
 
@@ -957,6 +1006,7 @@
 		recv_gsr->gsr_group.ss_family = family;
 
 /* track IPv6 scope from any resolved interface */
+		{
 		unsigned scope_id = 0;
 
 /* if using unspec default group check the interface for address family
@@ -1053,11 +1103,13 @@
 		*recv_list = pgm_list_append (*recv_list, recv_gsr);
 		pgm_free (primary_interface);
 		return TRUE;
+		}
 	}
 
 /* parse one or more multicast receive groups.
  */
 
+	{
 	int j = 0;	
 	char** tokens = pgm_strsplit (entity, ",", 10);
 	while (tokens && tokens[j])
@@ -1126,6 +1178,8 @@
 	pgm_strfreev (tokens);
 	pgm_free (primary_interface);
 	return TRUE;
+	}
+	}
 }
 
 static
@@ -1155,6 +1209,7 @@
 		(const void*)send_list,
 		(const void*)error);
 
+	{
 	struct group_source_req* send_gsr;
 	const struct interface_req* primary_interface = (struct interface_req*)(*interface_list)->data;
 
@@ -1201,6 +1256,7 @@
 	memcpy (&send_gsr->gsr_source, &send_gsr->gsr_group, pgm_sockaddr_len ((struct sockaddr*)&send_gsr->gsr_group));
 	*send_list = pgm_list_append (*send_list, send_gsr);
 	return TRUE;
+	}
 }
 
 /* parse network parameter
@@ -1333,9 +1389,14 @@
 			}
 
 /* entity from b to p-1 */
+			{
 			char entity[1024];
+#ifdef _MSC_VER
+			strncpy_s (entity, sizeof(entity), b, p - b);
+#else
 			strncpy (entity, b, sizeof(entity));
 			entity[p - b] = 0;
+#endif
 
 			switch (ec++) {
 			case ENTITY_INTERFACE:
@@ -1391,6 +1452,7 @@
 
 			b = ++p;
 			continue;
+			}
 		}
 
 		p++;
@@ -1540,6 +1602,7 @@
 
 	if (!network_parse (network, family, &recv_list, &send_list, error))
 		return FALSE;
+	{
 	const size_t recv_list_len = pgm_list_length (recv_list);
 	const size_t send_list_len = pgm_list_length (send_list);
 	ai = pgm_malloc0 (sizeof(struct pgm_addrinfo_t) + 
@@ -1548,7 +1611,8 @@
 	ai->ai_recv_addrs = (void*)((char*)ai + sizeof(struct pgm_addrinfo_t));
 	ai->ai_send_addrs_len = send_list_len;
 	ai->ai_send_addrs = (void*)((char*)ai->ai_recv_addrs + recv_list_len * sizeof(struct group_source_req));
-			
+
+	{
 	size_t i = 0;
 	while (recv_list) {
 		memcpy (&ai->ai_recv_addrs[i++], recv_list->data, sizeof(struct group_source_req));
@@ -1563,6 +1627,8 @@
 	}
 	*res = ai;
 	return TRUE;
+	}
+	}
 }
 
 void
