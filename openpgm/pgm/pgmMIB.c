/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.notify.conf,v 5.3 2004/04/15 12:29:19 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include "pgm/pgmMIB.h"
#include "pgm/pgmMIB_columns.h"
#include "pgm/pgmMIB_enums.h"
#include "pgm/txwi.h"
#include "pgm/transport.h"


struct pgm_snmp_context_t {
	GSList* list;
};

typedef struct pgm_snmp_context_t pgm_snmp_context_t;


/* local globals */
static oid snmptrap_oid[] = {1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0};


/* functions */

static int initialize_table_pgmSourceTable(void);
static int initialize_table_pgmSourceConfigTable(void);
static int initialize_table_pgmSourcePerformanceTable(void);
static Netsnmp_Node_Handler pgmSourceTable_handler;
static Netsnmp_Node_Handler pgmSourceConfigTable_handler;
static Netsnmp_Node_Handler pgmSourcePerformanceTable_handler;
static Netsnmp_First_Data_Point pgmSourceTable_get_first_data_point;
static Netsnmp_First_Data_Point pgmSourceConfigTable_get_first_data_point;
static Netsnmp_First_Data_Point pgmSourcePerformanceTable_get_first_data_point;
static Netsnmp_Next_Data_Point pgmSourceTable_get_next_data_point;
static Netsnmp_Next_Data_Point pgmSourceConfigTable_get_next_data_point;
static Netsnmp_Next_Data_Point pgmSourcePerformanceTable_get_next_data_point;
static Netsnmp_Free_Loop_Context pgmSourceTable_free_loop_context;
static Netsnmp_Free_Loop_Context pgmSourceConfigTable_free_loop_context;
static Netsnmp_Free_Loop_Context pgmSourcePerformanceTable_free_loop_context;


int
pgm_mib_init (void)
{
	int retval = 0;

	retval = initialize_table_pgmSourceTable();
	if (retval != MIB_REGISTERED_OK) {
		g_error ("pgmSourceTable registration failed.");
		goto out;
	}

	retval = initialize_table_pgmSourceConfigTable();
	if (retval != MIB_REGISTERED_OK) {
		g_error ("pgmSourceConfigTable registration failed.");
		goto out;
	}

	retval = initialize_table_pgmSourcePerformanceTable();
	if (retval != MIB_REGISTERED_OK) {
		g_error ("pgmSourcePerformanceTable registration failed.");
		goto out;
	}


#if 0
	initialize_table_pgmReceiverTable();
	initialize_table_pgmReceiverConfigTable();
	initialize_table_pgmReceiverPerformanceTable();
#endif

out:
	return retval;
}

/*
 * pgmSourceTable
 *
 * returns MIB_REGISTERED_OK on success, failures include:
 * 	MIB_REGISTRATION_FAILED
 * 	MIB_DUPLICATE_REGISTRATION
 * 	SNMPERR_GENERR
 */

static int
initialize_table_pgmSourceTable(void)
{
	static oid pgmSourceTable_oid[] = {1,3,6,1,3,112,1,2,100,2};
	netsnmp_table_registration_info* table_info = NULL;
	netsnmp_iterator_info* iinfo = NULL;
	netsnmp_handler_registration* reg = NULL;

	reg = netsnmp_create_handler_registration(
						"pgmSourceTable",	pgmSourceTable_handler,
						pgmSourceTable_oid,	OID_LENGTH(pgmSourceTable_oid),
						HANDLER_CAN_RONLY
						);
	if (!reg)
		goto error;

	table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
	if (!table_info)
		goto error;

	table_info->min_column = COLUMN_PGMSOURCESOURCEADDRESS;
	table_info->max_column = COLUMN_PGMSOURCESOURCEPORTNUMBER;

	netsnmp_table_helper_add_indexes(table_info,
						ASN_OCTET_STR,  /* index: pgmSourceGlobalId */
						ASN_UNSIGNED,  /* index: pgmSourceSourcePort */
						0);

	iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
	if (!iinfo)
		goto error;

	iinfo->get_first_data_point = pgmSourceTable_get_first_data_point;
	iinfo->get_next_data_point  = pgmSourceTable_get_next_data_point;
	iinfo->free_loop_context_at_end = pgmSourceTable_free_loop_context;
	iinfo->table_reginfo        = table_info;

	return netsnmp_register_table_iterator( reg, iinfo );

error:
	if (table_info && table_info->indexes)		/* table_data_free_func() is internal */
		snmp_free_var(table_info->indexes);
	SNMP_FREE(table_info);
	SNMP_FREE(iinfo);
	netsnmp_handler_registration_free (reg);

	return -1;
}

/* called for first row of data in SNMP table
 *
 * goal is to cache all the relevant data for subsequent get_next_data_point (row) calls in my_loop_context,
 * optionally returns my_data_context.
 *
 * returns answer or NULL
 */

static netsnmp_variable_list*
pgmSourceTable_get_first_data_point(
	void**			my_loop_context,	/* valid through one query of multiple "data points" */
	void**			my_data_context,	/* answer blob which is passed to handler() */
	netsnmp_variable_list*	put_index_data,		/* answer */
	netsnmp_iterator_info*	mydata)			/* iinfo on init() */
{
g_message ("first_data_point");
	g_static_rw_lock_reader_lock (&pgm_transport_list_lock);

	if (pgm_transport_list == NULL) {
		g_static_rw_lock_reader_unlock (&pgm_transport_list_lock);
		return NULL;
	}

/* create our own context for this SNMP loop */
	pgm_snmp_context_t* context = g_malloc0 (sizeof(pgm_snmp_context_t));
	context->list = pgm_transport_list;
	*my_loop_context = context;

/* pass on for generic row access */
	return pgmSourceTable_get_next_data_point (my_loop_context, my_data_context, put_index_data, mydata);
}

static netsnmp_variable_list*
pgmSourceTable_get_next_data_point(
	void**			my_loop_context,
	void**			my_data_context,
	netsnmp_variable_list*	put_index_data,
	netsnmp_iterator_info*	mydata)
{
g_message("next_data_point");
	pgm_snmp_context_t* context = (pgm_snmp_context_t*)*my_loop_context;
	netsnmp_variable_list *idx = put_index_data;

	if ( context->list == NULL )
	{
g_message("return NULL");
		return NULL;
	}

	pgm_transport_t* transport = context->list->data;

/* pgmSourceGlobalId */
	char gsi[sizeof("000" "000" "000" "000" "000" "000")];
	snprintf(gsi, sizeof(gsi), "%hhu%hhu%hhu%hhu%hhu%hhu",
		transport->tsi.gsi.identifier[0],
		transport->tsi.gsi.identifier[1],
		transport->tsi.gsi.identifier[2],
		transport->tsi.gsi.identifier[3],
		transport->tsi.gsi.identifier[4],
		transport->tsi.gsi.identifier[5]);
	snmp_set_var_typed_value( idx, ASN_OCTET_STR, (u_char*)&gsi, strlen(gsi) );
	idx = idx->next_variable;

/* pgmSourceSourcePort */
	unsigned long sport = g_ntohs (transport->tsi.sport);
	snmp_set_var_typed_value( idx, ASN_UNSIGNED, (u_char*)&sport, sizeof(sport) );

	*my_data_context = transport;
	context->list = context->list->next;

	return put_index_data;
}

static void
pgmSourceTable_free_loop_context (
	void*			my_loop_context,
	netsnmp_iterator_info*	mydata)
{
	pgm_snmp_context_t* context = (pgm_snmp_context_t*)my_loop_context;
	g_free(context);
	my_loop_context = NULL;

	g_static_rw_lock_reader_unlock (&pgm_transport_list_lock);
}

static int
pgmSourceTable_handler (
	netsnmp_mib_handler*		handler,
	netsnmp_handler_registration*	reginfo,
	netsnmp_agent_request_info*	reqinfo,
	netsnmp_request_info*		requests)
{
g_message("handler");
	switch (reqinfo->mode)
	{

/* Read-support (also covers GetNext requests) */

	case MODE_GET:
		for (netsnmp_request_info* request=requests; request; request=request->next)
		{
			pgm_transport_t* transport = (pgm_transport_t*)netsnmp_extract_iterator_context(request);

			if (transport == NULL) {
				netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
				continue;
			}

			netsnmp_variable_list *var = request->requestvb;
			netsnmp_table_request_info* table_info = netsnmp_extract_table_info(request);

			if (table_info == NULL) {
				snmp_log (LOG_ERR, "pgmSourceTable_handler: empty table request info.\n");
				continue;
			}

g_message("request %i on %p", table_info->colnum, transport);
			switch (table_info->colnum)
			{
			case COLUMN_PGMSOURCESOURCEADDRESS:
				snmp_set_var_typed_value(	var, ASN_IPADDRESS,
								(u_char*)pgm_sockaddr_addr( &transport->send_smr.smr_interface ),
								pgm_sockaddr_len( &transport->send_smr.smr_interface ));
				break;

			case COLUMN_PGMSOURCEGROUPADDRESS:
				snmp_set_var_typed_value(	var, ASN_IPADDRESS,
								(u_char*)pgm_sockaddr_addr( &transport->send_smr.smr_multiaddr ),
								pgm_sockaddr_len( &transport->send_smr.smr_multiaddr ));
				break;

			case COLUMN_PGMSOURCEDESTPORT:
				{
				unsigned long dport = g_ntohs (transport->dport);
				snmp_set_var_typed_value(	var, ASN_UNSIGNED,
								(u_char*)&dport, sizeof(dport) );
				}
				break;

			case COLUMN_PGMSOURCESOURCEGSI:
/* copy index[0] */
				snmp_set_var_typed_value(	var, ASN_OCTET_STR,
								(u_char*)table_info->indexes->val.string,
								table_info->indexes->val_len);
				break;

			case COLUMN_PGMSOURCESOURCEPORTNUMBER:
/* copy index[1] */
				snmp_set_var_typed_value(	var, ASN_UNSIGNED,
								(u_char*)table_info->indexes->next_variable->val.integer,
								table_info->indexes->next_variable->val_len);
				break;

			default:
				snmp_log (LOG_ERR, "pgmSourceTable_handler: unknown column.\n");
				break;
			}
		}
		break;

	case MODE_SET_RESERVE1:
	default:
		snmp_log (LOG_ERR, "pgmSourceTable_handler: unsupported mode.\n");
		break;

	}

	return SNMP_ERR_NOERROR;
}

/*
 * pgmSourceConfigTable
 *
 */

static int
initialize_table_pgmSourceConfigTable(void)
{
	static oid pgmSourceConfigTable_oid[] = {1,3,6,1,3,112,1,2,100,3};
	netsnmp_table_registration_info* table_info = NULL;
	netsnmp_iterator_info* iinfo = NULL;
	netsnmp_handler_registration* reg = NULL;

	reg = netsnmp_create_handler_registration(
						"pgmSourceConfigTable",		pgmSourceConfigTable_handler,
						pgmSourceConfigTable_oid,	OID_LENGTH(pgmSourceConfigTable_oid),
						HANDLER_CAN_RONLY
						);
	if (!reg)
		goto error;

	table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
	if (!table_info)
		goto error;

	table_info->min_column = COLUMN_PGMSOURCETTL;
	table_info->max_column = COLUMN_PGMSOURCESPMPATHADDRESS;

	netsnmp_table_helper_add_indexes(table_info,
						ASN_OCTET_STR,  /* index: pgmSourceConfigGlobalId */
						ASN_UNSIGNED,  /* index: pgmSourceConfigSourcePort */
						0);

	iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
	if (!iinfo)
		goto error;

	iinfo->get_first_data_point = pgmSourceConfigTable_get_first_data_point;
	iinfo->get_next_data_point  = pgmSourceConfigTable_get_next_data_point;
	iinfo->free_loop_context_at_end = pgmSourceConfigTable_free_loop_context;
	iinfo->table_reginfo        = table_info;

	return netsnmp_register_table_iterator( reg, iinfo );

error:
	if (table_info && table_info->indexes)		/* table_data_free_func() is internal */
		snmp_free_var(table_info->indexes);
	SNMP_FREE(table_info);
	SNMP_FREE(iinfo);
	netsnmp_handler_registration_free (reg);

	return -1;
}

/* called for first row of data in SNMP table
 *
 * goal is to cache all the relevant data for subsequent get_next_data_point (row) calls in my_loop_context,
 * optionally returns my_data_context.
 *
 * returns answer or NULL
 */

static netsnmp_variable_list*
pgmSourceConfigTable_get_first_data_point(
	void**			my_loop_context,	/* valid through one query of multiple "data points" */
	void**			my_data_context,	/* answer blob which is passed to handler() */
	netsnmp_variable_list*	put_index_data,		/* answer */
	netsnmp_iterator_info*	mydata)			/* iinfo on init() */
{
	g_static_rw_lock_reader_lock (&pgm_transport_list_lock);

	if (pgm_transport_list == NULL) {
		g_static_rw_lock_reader_unlock (&pgm_transport_list_lock);
		return NULL;
	}

/* create our own context for this SNMP loop */
	pgm_snmp_context_t* context = g_malloc0 (sizeof(pgm_snmp_context_t));
	context->list = pgm_transport_list;
	*my_loop_context = context;

/* pass on for generic row access */
	return pgmSourceConfigTable_get_next_data_point (my_loop_context, my_data_context, put_index_data, mydata);
}

static netsnmp_variable_list*
pgmSourceConfigTable_get_next_data_point(
	void**			my_loop_context,
	void**			my_data_context,
	netsnmp_variable_list*	put_index_data,
	netsnmp_iterator_info*	mydata)
{
	pgm_snmp_context_t* context = (pgm_snmp_context_t*)*my_loop_context;
	netsnmp_variable_list *idx = put_index_data;

	if ( context->list == NULL )
	{
g_message("return NULL");
		return NULL;
	}

	pgm_transport_t* transport = context->list->data;

/* pgmSourceGlobalId */
	char gsi[sizeof("000" "000" "000" "000" "000" "000")];
	snprintf(gsi, sizeof(gsi), "%hhu%hhu%hhu%hhu%hhu%hhu",
		transport->tsi.gsi.identifier[0],
		transport->tsi.gsi.identifier[1],
		transport->tsi.gsi.identifier[2],
		transport->tsi.gsi.identifier[3],
		transport->tsi.gsi.identifier[4],
		transport->tsi.gsi.identifier[5]);
	snmp_set_var_typed_value( idx, ASN_OCTET_STR, (u_char*)&gsi, strlen(gsi) );
	idx = idx->next_variable;

/* pgmSourceSourcePort */
	unsigned long sport = g_ntohs (transport->tsi.sport);
	snmp_set_var_typed_value( idx, ASN_UNSIGNED, (u_char*)&sport, sizeof(sport) );

	*my_data_context = transport;
	context->list = context->list->next;

	return put_index_data;
}

static void
pgmSourceConfigTable_free_loop_context (
	void*			my_loop_context,
	netsnmp_iterator_info*	mydata)
{
	pgm_snmp_context_t* context = (pgm_snmp_context_t*)my_loop_context;
	g_free(context);
	my_loop_context = NULL;

	g_static_rw_lock_reader_unlock (&pgm_transport_list_lock);
}

static int
pgmSourceConfigTable_handler (
	netsnmp_mib_handler*		handler,
	netsnmp_handler_registration*	reginfo,
	netsnmp_agent_request_info*	reqinfo,
	netsnmp_request_info*		requests)
{
	switch (reqinfo->mode)
	{

/* Read-support (also covers GetNext requests) */

	case MODE_GET:
		for (netsnmp_request_info* request=requests; request; request=request->next)
		{
			pgm_transport_t* transport = (pgm_transport_t*)netsnmp_extract_iterator_context(request);

			if (transport == NULL) {
				netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
				continue;
			}

			netsnmp_variable_list *var = request->requestvb;
			netsnmp_table_request_info* table_info = netsnmp_extract_table_info(request);

			if (table_info == NULL) {
				snmp_log (LOG_ERR, "pgmSourceTable_handler: empty table request info.\n");
				continue;
			}

			switch (table_info->colnum)
			{
			case COLUMN_PGMSOURCETTL:
				{
				unsigned long hops = transport->hops;
				snmp_set_var_typed_value(	var, ASN_UNSIGNED,
								(u_char*)&hops, sizeof(hops) );
				}
				break;

/* FIXED: pgmSourceAdvMode = data(1) */
			case COLUMN_PGMSOURCEADVMODE:
				{
				unsigned long adv_mode = PGMSOURCEADVMODE_DATA;
				snmp_set_var_typed_value(	var, ASN_INTEGER,
								(u_char*)&adv_mode, sizeof(adv_mode) );
				}
				break;

/* FIXED: pgmSourceLateJoin = disable(2) */
			case COLUMN_PGMSOURCELATEJOIN:
				{
				unsigned long late_join = PGMSOURCELATEJOIN_DISABLE;
				snmp_set_var_typed_value(	var, ASN_INTEGER,
								(u_char*)&late_join, sizeof(late_join) );
				}
				break;

			case COLUMN_PGMSOURCETXWMAXRTE:
				{
				unsigned long txw_max_rte = transport->txw_max_rte;
				snmp_set_var_typed_value(	var, ASN_UNSIGNED,
								(u_char*)&txw_max_rte, sizeof(txw_max_rte) );
				}
				break;

			case COLUMN_PGMSOURCETXWSECS:
				{
				unsigned long txw_secs = transport->txw_secs;
				snmp_set_var_typed_value(	var, ASN_UNSIGNED,
								(u_char*)&txw_secs, sizeof(txw_secs) );
				}
				break;

/* FIXED: TXW_ADV_SECS = 0 */
			case COLUMN_PGMSOURCETXWADVSECS:
				{
				unsigned long txw_adv_secs = 0;
				snmp_set_var_typed_value(	var, ASN_UNSIGNED,
								(u_char*)&txw_adv_secs, sizeof(txw_adv_secs) );
				}
				break;

/* FIXED: pgmSourceAdvIvl = TXW_ADV_SECS * 1000 = 0 */
			case COLUMN_PGMSOURCEADVIVL:
				{
				unsigned long adv_ivl = 0;
				snmp_set_var_typed_value(	var, ASN_UNSIGNED,
								(u_char*)&adv_ivl, sizeof(adv_ivl) );
				}
				break;

			case COLUMN_PGMSOURCESPMIVL:
				{
				unsigned long spm_ivl = pgm_to_msecs(transport->spm_ambient_interval);
				snmp_set_var_typed_value(	var, ASN_UNSIGNED,
								(u_char*)&spm_ivl, sizeof(spm_ivl) );
				}
				break;

/* TODO: IHB_MIN */
			case COLUMN_PGMSOURCESPMHEARTBEATIVLMIN:
				{
				unsigned long ihb_min = 0;
				snmp_set_var_typed_value(	var, ASN_UNSIGNED,
								(u_char*)&ihb_min, sizeof(ihb_min) );
				}
				break;

/* TODO: IHB_MAX */
			case COLUMN_PGMSOURCESPMHEARTBEATIVLMAX:
				{
				unsigned long ihb_max = 0;
				snmp_set_var_typed_value(	var, ASN_UNSIGNED,
								(u_char*)&ihb_max, sizeof(ihb_max) );
				}
				break;

/* NAK_RB_IVL */
			case COLUMN_PGMSOURCERDATABACKOFFIVL:
				{
				unsigned long nak_rb_ivl = pgm_to_msecs(transport->nak_rb_ivl);
				snmp_set_var_typed_value(	var, ASN_UNSIGNED,
								(u_char*)&nak_rb_ivl, sizeof(nak_rb_ivl) );
				}
				break;

/* FIXED: pgmSourceFEC = disabled(1) */
			case COLUMN_PGMSOURCEFEC:
				{
				unsigned long fec = PGMSOURCEADVMODE_DATA;
				snmp_set_var_typed_value(	var, ASN_INTEGER,
								(u_char*)&fec, sizeof(fec) );
				}
				break;

/* FIXED: pgmSourceFECTransmissionGrpSize = 0 */
			case COLUMN_PGMSOURCEFECTRANSMISSIONGRPSIZE:
				{
				unsigned long fec_tgs = 0;
				snmp_set_var_typed_value(	var, ASN_UNSIGNED,
								(u_char*)&fec_tgs, sizeof(fec_tgs) );
				}
				break;

/* FIXED: pgmSourceFECProactiveParitySize = 0 */
			case COLUMN_PGMSOURCEFECPROACTIVEPARITYSIZE:
				{
				unsigned long fec_paps = 0;
				snmp_set_var_typed_value(	var, ASN_UNSIGNED,
								(u_char*)&fec_paps, sizeof(fec_paps) );
				}
				break;

			case COLUMN_PGMSOURCESPMPATHADDRESS:
				snmp_set_var_typed_value(	var, ASN_IPADDRESS,
								(u_char*)pgm_sockaddr_addr( &transport->recv_smr[0].smr_interface ),
								pgm_sockaddr_len( &transport->recv_smr[0].smr_interface ));
				break;

			default:
				snmp_log (LOG_ERR, "pgmSourceConfigTable_handler: unknown column.\n");
				break;
			}
		}
		break;

	case MODE_SET_RESERVE1:
	default:
		snmp_log (LOG_ERR, "pgmSourceConfigTable_handler: unsupported mode.\n");
		break;

	}

	return SNMP_ERR_NOERROR;
}

/*
 * pgmSourcePerformanceTable
 */

static int
initialize_table_pgmSourcePerformanceTable(void)
{
	static oid pgmSourcePerformanceTable_oid[] = {1,3,6,1,3,112,1,2,100,4};
	netsnmp_table_registration_info* table_info = NULL;
	netsnmp_iterator_info* iinfo = NULL;
	netsnmp_handler_registration* reg = NULL;

	reg = netsnmp_create_handler_registration(
						"pgmSourcePerformanceTable",	pgmSourcePerformanceTable_handler,
						pgmSourcePerformanceTable_oid,	OID_LENGTH(pgmSourcePerformanceTable_oid),
						HANDLER_CAN_RONLY
						);
	if (!reg)
		goto error;

	table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
	if (!table_info)
		goto error;

	table_info->min_column = COLUMN_PGMSOURCEDATABYTESSENT;
	table_info->max_column = COLUMN_PGMSOURCENNAKERRORS;

	netsnmp_table_helper_add_indexes(table_info,
						ASN_OCTET_STR,  /* index: pgmSourceGlobalId */
						ASN_UNSIGNED,  /* index: pgmSourceSourcePort */
						0);

	iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
	if (!iinfo)
		goto error;

	iinfo->get_first_data_point = pgmSourcePerformanceTable_get_first_data_point;
	iinfo->get_next_data_point  = pgmSourcePerformanceTable_get_next_data_point;
	iinfo->free_loop_context_at_end = pgmSourcePerformanceTable_free_loop_context;
	iinfo->table_reginfo        = table_info;

	return netsnmp_register_table_iterator( reg, iinfo );

error:
	if (table_info && table_info->indexes)		/* table_data_free_func() is internal */
		snmp_free_var(table_info->indexes);
	SNMP_FREE(table_info);
	SNMP_FREE(iinfo);
	netsnmp_handler_registration_free (reg);

	return -1;
}

/* called for first row of data in SNMP table
 *
 * goal is to cache all the relevant data for subsequent get_next_data_point (row) calls in my_loop_context,
 * optionally returns my_data_context.
 *
 * returns answer or NULL
 */

static netsnmp_variable_list*
pgmSourcePerformanceTable_get_first_data_point(
	void**			my_loop_context,	/* valid through one query of multiple "data points" */
	void**			my_data_context,	/* answer blob which is passed to handler() */
	netsnmp_variable_list*	put_index_data,		/* answer */
	netsnmp_iterator_info*	mydata)			/* iinfo on init() */
{
	g_static_rw_lock_reader_lock (&pgm_transport_list_lock);

	if (pgm_transport_list == NULL) {
		g_static_rw_lock_reader_unlock (&pgm_transport_list_lock);
		return NULL;
	}

/* create our own context for this SNMP loop */
	pgm_snmp_context_t* context = g_malloc0 (sizeof(pgm_snmp_context_t));
	context->list = pgm_transport_list;
	*my_loop_context = context;

/* pass on for generic row access */
	return pgmSourcePerformanceTable_get_next_data_point (my_loop_context, my_data_context, put_index_data, mydata);
}

static netsnmp_variable_list*
pgmSourcePerformanceTable_get_next_data_point(
	void**			my_loop_context,
	void**			my_data_context,
	netsnmp_variable_list*	put_index_data,
	netsnmp_iterator_info*	mydata)
{
	pgm_snmp_context_t* context = (pgm_snmp_context_t*)*my_loop_context;
	netsnmp_variable_list *idx = put_index_data;

	if ( context->list == NULL )
	{
g_message("return NULL");
		return NULL;
	}

	pgm_transport_t* transport = context->list->data;

/* pgmSourceGlobalId */
	char gsi[sizeof("000" "000" "000" "000" "000" "000")];
	snprintf(gsi, sizeof(gsi), "%hhu%hhu%hhu%hhu%hhu%hhu",
		transport->tsi.gsi.identifier[0],
		transport->tsi.gsi.identifier[1],
		transport->tsi.gsi.identifier[2],
		transport->tsi.gsi.identifier[3],
		transport->tsi.gsi.identifier[4],
		transport->tsi.gsi.identifier[5]);
	snmp_set_var_typed_value( idx, ASN_OCTET_STR, (u_char*)&gsi, strlen(gsi) );
	idx = idx->next_variable;

/* pgmSourceSourcePort */
	unsigned long sport = g_ntohs (transport->tsi.sport);
	snmp_set_var_typed_value( idx, ASN_UNSIGNED, (u_char*)&sport, sizeof(sport) );

	*my_data_context = transport;
	context->list = context->list->next;

	return put_index_data;
}

static void
pgmSourcePerformanceTable_free_loop_context (
	void*			my_loop_context,
	netsnmp_iterator_info*	mydata)
{
	pgm_snmp_context_t* context = (pgm_snmp_context_t*)my_loop_context;
	g_free(context);
	my_loop_context = NULL;

	g_static_rw_lock_reader_unlock (&pgm_transport_list_lock);
}

static int
pgmSourcePerformanceTable_handler (
	netsnmp_mib_handler*		handler,
	netsnmp_handler_registration*	reginfo,
	netsnmp_agent_request_info*	reqinfo,
	netsnmp_request_info*		requests)
{
	switch (reqinfo->mode)
	{

/* Read-support (also covers GetNext requests) */

	case MODE_GET:
		for (netsnmp_request_info* request=requests; request; request=request->next)
		{
			pgm_transport_t* transport = (pgm_transport_t*)netsnmp_extract_iterator_context(request);

			if (transport == NULL) {
				netsnmp_set_request_error (reqinfo, request, SNMP_NOSUCHINSTANCE);
				continue;
			}

			netsnmp_variable_list *var = request->requestvb;
			netsnmp_table_request_info* table_info = netsnmp_extract_table_info(request);

			if (table_info == NULL) {
				snmp_log (LOG_ERR, "pgmSourceTable_handler: empty table request info.\n");
				continue;
			}

			switch (table_info->colnum)
			{
			case COLUMN_PGMSOURCEDATABYTESSENT:
				{
				unsigned long data_bytes = transport->cumulative_stats[PGM_PC_SOURCE_DATA_BYTES_SENT];
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&data_bytes, sizeof(data_bytes) );
				}
				break;

			case COLUMN_PGMSOURCEDATAMSGSSENT:
				{
				unsigned long data_msgs = transport->cumulative_stats[PGM_PC_SOURCE_DATA_MSGS_SENT];
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&data_msgs, sizeof(data_msgs) );
				}
				break;

			case COLUMN_PGMSOURCEBYTESBUFFERED:
				{
				unsigned long bytes_buffered = ((pgm_txw_t*)transport->txw)->bytes_in_window;
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&bytes_buffered, sizeof(bytes_buffered) );
				}
				break;

			case COLUMN_PGMSOURCEMSGSBUFFERED:
				{
				unsigned long msgs_buffered = ((pgm_txw_t*)transport->txw)->packets_in_window;
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&msgs_buffered, sizeof(msgs_buffered) );
				}
				break;

/* PGM_PC_SOURCE_SELECTIVE_BYTES_RETRANSMITTED + COLUMN_PGMSOURCEPARITYBYTESRETRANSMITTED */
			case COLUMN_PGMSOURCEBYTESRETRANSMITTED:
				{
				unsigned long bytes_resent = transport->cumulative_stats[PGM_PC_SOURCE_SELECTIVE_BYTES_RETRANSMITTED];
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&bytes_resent, sizeof(bytes_resent) );
				}
				break;

/* PGM_PC_SOURCE_SELECTIVE_MSGS_RETRANSMITTED + COLUMN_PGMSOURCEPARITYMSGSRETRANSMITTED */
			case COLUMN_PGMSOURCEMSGSRETRANSMITTED:
				{
				unsigned long msgs_resent = transport->cumulative_stats[PGM_PC_SOURCE_SELECTIVE_MSGS_RETRANSMITTED];
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&msgs_resent, sizeof(msgs_resent) );
				}
				break;

			case COLUMN_PGMSOURCEBYTESSENT:
				{
				unsigned long bytes_sent = transport->cumulative_stats[PGM_PC_SOURCE_BYTES_SENT];
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&bytes_sent, sizeof(bytes_sent) );
				}
				break;

/* COLUMN_PGMSOURCEPARITYNAKPACKETSRECEIVED + COLUMN_PGMSOURCESELECTIVENAKPACKETSRECEIVED */
			case COLUMN_PGMSOURCERAWNAKSRECEIVED:
				{
				unsigned long nak_packets = transport->cumulative_stats[PGM_PC_SOURCE_SELECTIVE_NAKS_RECEIVED];
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&nak_packets, sizeof(nak_packets) );
				}
				break;

/* PGM_PC_SOURCE_SELECTIVE_NAKS_IGNORED + COLUMN_PGMSOURCEPARITYNAKSIGNORED */
			case COLUMN_PGMSOURCENAKSIGNORED:
				{
				unsigned long naks_ignored = transport->cumulative_stats[PGM_PC_SOURCE_SELECTIVE_NAKS_IGNORED];
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&naks_ignored, sizeof(naks_ignored) );
				}
				break;

			case COLUMN_PGMSOURCECKSUMERRORS:
				{
				unsigned long cksum_errors = transport->cumulative_stats[PGM_PC_SOURCE_CKSUM_ERRORS];
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&cksum_errors, sizeof(cksum_errors) );
				}
				break;

			case COLUMN_PGMSOURCEMALFORMEDNAKS:
				{
				unsigned long malformed_naks = transport->cumulative_stats[PGM_PC_SOURCE_MALFORMED_NAKS];
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&malformed_naks, sizeof(malformed_naks) );
				}
				break;

			case COLUMN_PGMSOURCEPACKETSDISCARDED:
				{
				unsigned long packets_discarded = transport->cumulative_stats[PGM_PC_SOURCE_PACKETS_DISCARDED];
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&packets_discarded, sizeof(packets_discarded) );
				}
				break;

/* PGM_PC_SOURCE_SELECTIVE_NAKS_RECEIVED + COLUMN_PGMSOURCEPARITYNAKSRECEIVED */
			case COLUMN_PGMSOURCENAKSRCVD:
				{
				unsigned long naks_received = transport->cumulative_stats[PGM_PC_SOURCE_SELECTIVE_NAKS_RECEIVED];
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&naks_received, sizeof(naks_received) );
				}
				break;

/* FIXED: 0 */
			case COLUMN_PGMSOURCEPARITYBYTESRETRANSMITTED:
				{
				unsigned long parity_bytes_resent = 0;
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&parity_bytes_resent, sizeof(parity_bytes_resent) );
				}
				break;

			case COLUMN_PGMSOURCESELECTIVEBYTESRETRANSMITED:
				{
				unsigned long selective_bytes_resent = transport->cumulative_stats[PGM_PC_SOURCE_SELECTIVE_BYTES_RETRANSMITTED];
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&selective_bytes_resent, sizeof(selective_bytes_resent) );
				}
				break;

/* FIXED: 0 */
			case COLUMN_PGMSOURCEPARITYMSGSRETRANSMITTED:
				{
				unsigned long parity_msgs_resent = 0;
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&parity_msgs_resent, sizeof(parity_msgs_resent) );
				}
				break;

			case COLUMN_PGMSOURCESELECTIVEMSGSRETRANSMITTED:
				{
				unsigned long selective_msgs_resent = transport->cumulative_stats[PGM_PC_SOURCE_SELECTIVE_MSGS_RETRANSMITTED];
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&selective_msgs_resent, sizeof(selective_msgs_resent) );
				}
				break;

/* FIXED: 0 */
			case COLUMN_PGMSOURCEBYTESADMIT:
				{
				unsigned long bytes_admit = 0;
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&bytes_admit, sizeof(bytes_admit) );
				}
				break;

/* FIXED: 0 */
			case COLUMN_PGMSOURCEMSGSADMIT:
				{
				unsigned long msgs_admit = 0;
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&msgs_admit, sizeof(msgs_admit) );
				}
				break;

/* FIXED: 0 */
			case COLUMN_PGMSOURCEPARITYNAKPACKETSRECEIVED:
				{
				unsigned long parity_nak_packets = 0;
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&parity_nak_packets, sizeof(parity_nak_packets) );
				}
				break;

			case COLUMN_PGMSOURCESELECTIVENAKPACKETSRECEIVED:
				{
				unsigned long selective_nak_packets = transport->cumulative_stats[PGM_PC_SOURCE_SELECTIVE_NAKS_RECEIVED];
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&selective_nak_packets, sizeof(selective_nak_packets) );
				}
				break;

/* FIXED: 0 */
			case COLUMN_PGMSOURCEPARITYNAKSRECEIVED:
				{
				unsigned long parity_naks = 0;
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&parity_naks, sizeof(parity_naks) );
				}
				break;

			case COLUMN_PGMSOURCESELECTIVENAKSRECEIVED:
				{
				unsigned long selective_naks = transport->cumulative_stats[PGM_PC_SOURCE_SELECTIVE_NAKS_RECEIVED];
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&selective_naks, sizeof(selective_naks) );
				}
				break;

/* FIXED: 0 */
			case COLUMN_PGMSOURCEPARITYNAKSIGNORED:
				{
				unsigned long parity_naks_ignored = 0;
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&parity_naks_ignored, sizeof(parity_naks_ignored) );
				}
				break;

			case COLUMN_PGMSOURCESELECTIVENAKSIGNORED:
				{
				unsigned long selective_naks_ignored = transport->cumulative_stats[PGM_PC_SOURCE_SELECTIVE_NAKS_IGNORED];
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&selective_naks_ignored, sizeof(selective_naks_ignored) );
				}
				break;

/* FIXED: 0 */
			case COLUMN_PGMSOURCEACKERRORS:
				{
				unsigned long ack_errors = 0;
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&ack_errors, sizeof(ack_errors) );
				}
				break;

			case COLUMN_PGMSOURCEPGMCCACKER:
				snmp_set_var_typed_value(	var, ASN_IPADDRESS,
								(u_char*)0,
								0);
				break;

			case COLUMN_PGMSOURCETRANSMISSIONCURRENTRATE:
				{
				unsigned long tx_current_rate = transport->cumulative_stats[PGM_PC_SOURCE_TRANSMISSION_CURRENT_RATE];
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&tx_current_rate, sizeof(tx_current_rate) );
				}
				break;

/* FIXED: 0 */
			case COLUMN_PGMSOURCEACKPACKETSRECEIVED:
				{
				unsigned long ack_packets = 0;
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&ack_packets, sizeof(ack_packets) );
				}
				break;

/* COLUMN_PGMSOURCEPARITYNNAKPACKETSRECEIVED + COLUMN_PGMSOURCESELECTIVENNAKPACKETSRECEIVED */
			case COLUMN_PGMSOURCENNAKPACKETSRECEIVED:
				{
				unsigned long nnak_packets = transport->cumulative_stats[PGM_PC_SOURCE_SELECTIVE_NNAK_PACKETS_RECEIVED];
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&nnak_packets, sizeof(nnak_packets) );
				}
				break;

/* FIXED: 0 */
			case COLUMN_PGMSOURCEPARITYNNAKPACKETSRECEIVED:
				{
				unsigned long parity_nnak_packets = 0;
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&parity_nnak_packets, sizeof(parity_nnak_packets) );
				}
				break;

			case COLUMN_PGMSOURCESELECTIVENNAKPACKETSRECEIVED:
				{
				unsigned long selective_nnak_packets = transport->cumulative_stats[PGM_PC_SOURCE_SELECTIVE_NNAK_PACKETS_RECEIVED];
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&selective_nnak_packets, sizeof(selective_nnak_packets) );
				}
				break;

/* COLUMN_PGMSOURCEPARITYNNAKSRECEIVED + COLUMN_PGMSOURCESELECTIVENNAKSRECEIVED */
			case COLUMN_PGMSOURCENNAKSRECEIVED:
				{
				unsigned long nnaks_received = transport->cumulative_stats[PGM_PC_SOURCE_SELECTIVE_NNAKS_RECEIVED];
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&nnaks_received, sizeof(nnaks_received) );
				}
				break;

/* FIXED: 0 */
			case COLUMN_PGMSOURCEPARITYNNAKSRECEIVED:
				{
				unsigned long parity_nnaks = 0;
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&parity_nnaks, sizeof(parity_nnaks) );
				}
				break;

			case COLUMN_PGMSOURCESELECTIVENNAKSRECEIVED:
				{
				unsigned long selective_nnaks = transport->cumulative_stats[PGM_PC_SOURCE_SELECTIVE_NNAKS_RECEIVED];
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&selective_nnaks, sizeof(selective_nnaks) );
				}
				break;

			case COLUMN_PGMSOURCENNAKERRORS:
				{
				unsigned long malformed_nnaks = transport->cumulative_stats[PGM_PC_SOURCE_NNAK_ERRORS];
				snmp_set_var_typed_value(	var, ASN_COUNTER, /* ASN_COUNTER32 */
								(u_char*)&malformed_nnaks, sizeof(malformed_nnaks) );
				}
				break;

			default:
				snmp_log (LOG_ERR, "pgmSourcePerformanceTable_handler: unknown column.\n");
				break;
			}
		}
		break;

	case MODE_SET_RESERVE1:
	default:
		snmp_log (LOG_ERR, "pgmSourcePerformanceTable_handler: unsupported mode.\n");
		break;

	}

	return SNMP_ERR_NOERROR;
}

/*
 * SNMP TRAPS
 */

int
send_pgmStart_trap( void )
{
    netsnmp_variable_list  *var_list = NULL;
    oid pgmStart_oid[] = { 1,3,6,1,3,112,2,0,1 };

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
        snmptrap_oid, OID_LENGTH(snmptrap_oid),
        ASN_OBJECT_ID,
        pgmStart_oid, sizeof(pgmStart_oid));
    

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap( var_list );
    snmp_free_varbind( var_list );

    return SNMP_ERR_NOERROR;
}
int
send_pgmStop_trap( void )
{
    netsnmp_variable_list  *var_list = NULL;
    oid pgmStop_oid[] = { 1,3,6,1,3,112,2,0,2 };

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
        snmptrap_oid, OID_LENGTH(snmptrap_oid),
        ASN_OBJECT_ID,
        pgmStop_oid, sizeof(pgmStop_oid));
    

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap( var_list );
    snmp_free_varbind( var_list );

    return SNMP_ERR_NOERROR;
}
int
send_pgmNewSourceTrap_trap( void )
{
    netsnmp_variable_list  *var_list = NULL;
    oid pgmNewSourceTrap_oid[] = { 1,3,6,1,3,112,2,0,3 };
    oid pgmSourceSourceGsi_oid[] = { 1,3,6,1,3,112,1,2,100,2,1,6, /* insert index here */ };
    oid pgmSourceSourcePortNumber_oid[] = { 1,3,6,1,3,112,1,2,100,2,1,7, /* insert index here */ };

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
        snmptrap_oid, OID_LENGTH(snmptrap_oid),
        ASN_OBJECT_ID,
        pgmNewSourceTrap_oid, sizeof(pgmNewSourceTrap_oid));
    
    /*
     * Add any objects from the trap definition
     */
    snmp_varlist_add_variable(&var_list,
        pgmSourceSourceGsi_oid, OID_LENGTH(pgmSourceSourceGsi_oid),
        ASN_OCTET_STR,
        /* Set an appropriate value for pgmSourceSourceGsi */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmSourceSourcePortNumber_oid, OID_LENGTH(pgmSourceSourcePortNumber_oid),
        ASN_UNSIGNED,
        /* Set an appropriate value for pgmSourceSourcePortNumber */
        NULL, 0);

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap( var_list );
    snmp_free_varbind( var_list );

    return SNMP_ERR_NOERROR;
}
int
send_pgmClosedSourceTrap_trap( void )
{
    netsnmp_variable_list  *var_list = NULL;
    oid pgmClosedSourceTrap_oid[] = { 1,3,6,1,3,112,2,0,4 };
    oid pgmSourceSourceGsi_oid[] = { 1,3,6,1,3,112,1,2,100,2,1,6, /* insert index here */ };
    oid pgmSourceSourcePortNumber_oid[] = { 1,3,6,1,3,112,1,2,100,2,1,7, /* insert index here */ };

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
        snmptrap_oid, OID_LENGTH(snmptrap_oid),
        ASN_OBJECT_ID,
        pgmClosedSourceTrap_oid, sizeof(pgmClosedSourceTrap_oid));
    
    /*
     * Add any objects from the trap definition
     */
    snmp_varlist_add_variable(&var_list,
        pgmSourceSourceGsi_oid, OID_LENGTH(pgmSourceSourceGsi_oid),
        ASN_OCTET_STR,
        /* Set an appropriate value for pgmSourceSourceGsi */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmSourceSourcePortNumber_oid, OID_LENGTH(pgmSourceSourcePortNumber_oid),
        ASN_UNSIGNED,
        /* Set an appropriate value for pgmSourceSourcePortNumber */
        NULL, 0);

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap( var_list );
    snmp_free_varbind( var_list );

    return SNMP_ERR_NOERROR;
}
int
send_pgmNewReceiverTrap_trap( void )
{
    netsnmp_variable_list  *var_list = NULL;
    oid pgmNewReceiverTrap_oid[] = { 1,3,6,1,3,112,2,0,5 };
    oid pgmReceiverSourceGsi_oid[] = { 1,3,6,1,3,112,1,3,100,2,1,8, /* insert index here */ };
    oid pgmReceiverSourcePortNumber_oid[] = { 1,3,6,1,3,112,1,3,100,2,1,9, /* insert index here */ };
    oid pgmReceiverUniqueInstance_oid[] = { 1,3,6,1,3,112,1,3,100,2,1,10, /* insert index here */ };

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
        snmptrap_oid, OID_LENGTH(snmptrap_oid),
        ASN_OBJECT_ID,
        pgmNewReceiverTrap_oid, sizeof(pgmNewReceiverTrap_oid));
    
    /*
     * Add any objects from the trap definition
     */
    snmp_varlist_add_variable(&var_list,
        pgmReceiverSourceGsi_oid, OID_LENGTH(pgmReceiverSourceGsi_oid),
        ASN_OCTET_STR,
        /* Set an appropriate value for pgmReceiverSourceGsi */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmReceiverSourcePortNumber_oid, OID_LENGTH(pgmReceiverSourcePortNumber_oid),
        ASN_UNSIGNED,
        /* Set an appropriate value for pgmReceiverSourcePortNumber */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmReceiverUniqueInstance_oid, OID_LENGTH(pgmReceiverUniqueInstance_oid),
        ASN_UNSIGNED,
        /* Set an appropriate value for pgmReceiverUniqueInstance */
        NULL, 0);

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap( var_list );
    snmp_free_varbind( var_list );

    return SNMP_ERR_NOERROR;
}
int
send_pgmClosedReceiverTrap_trap( void )
{
    netsnmp_variable_list  *var_list = NULL;
    oid pgmClosedReceiverTrap_oid[] = { 1,3,6,1,3,112,2,0,6 };
    oid pgmReceiverSourceGsi_oid[] = { 1,3,6,1,3,112,1,3,100,2,1,8, /* insert index here */ };
    oid pgmReceiverSourcePortNumber_oid[] = { 1,3,6,1,3,112,1,3,100,2,1,9, /* insert index here */ };
    oid pgmReceiverUniqueInstance_oid[] = { 1,3,6,1,3,112,1,3,100,2,1,10, /* insert index here */ };

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
        snmptrap_oid, OID_LENGTH(snmptrap_oid),
        ASN_OBJECT_ID,
        pgmClosedReceiverTrap_oid, sizeof(pgmClosedReceiverTrap_oid));
    
    /*
     * Add any objects from the trap definition
     */
    snmp_varlist_add_variable(&var_list,
        pgmReceiverSourceGsi_oid, OID_LENGTH(pgmReceiverSourceGsi_oid),
        ASN_OCTET_STR,
        /* Set an appropriate value for pgmReceiverSourceGsi */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmReceiverSourcePortNumber_oid, OID_LENGTH(pgmReceiverSourcePortNumber_oid),
        ASN_UNSIGNED,
        /* Set an appropriate value for pgmReceiverSourcePortNumber */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmReceiverUniqueInstance_oid, OID_LENGTH(pgmReceiverUniqueInstance_oid),
        ASN_UNSIGNED,
        /* Set an appropriate value for pgmReceiverUniqueInstance */
        NULL, 0);

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap( var_list );
    snmp_free_varbind( var_list );

    return SNMP_ERR_NOERROR;
}
int
send_pgmNakFailuresTrap_trap( void )
{
    netsnmp_variable_list  *var_list = NULL;
    oid pgmNakFailuresTrap_oid[] = { 1,3,6,1,3,112,2,0,7 };
    oid pgmReceiverSourceGsi_oid[] = { 1,3,6,1,3,112,1,3,100,2,1,8, /* insert index here */ };
    oid pgmReceiverSourcePortNumber_oid[] = { 1,3,6,1,3,112,1,3,100,2,1,9, /* insert index here */ };
    oid pgmReceiverUniqueInstance_oid[] = { 1,3,6,1,3,112,1,3,100,2,1,10, /* insert index here */ };
    oid pgmReceiverNakFailureThresholdTimer_oid[] = { 1,3,6,1,3,112,1,3,100,3,1,14, /* insert index here */ };
    oid pgmReceiverNakFailureThreshold_oid[] = { 1,3,6,1,3,112,1,3,100,3,1,15, /* insert index here */ };
    oid pgmReceiverNakFailuresLastInterval_oid[] = { 1,3,6,1,3,112,1,3,100,4,1,56, /* insert index here */ };
    oid pgmReceiverLastIntervalNakFailures_oid[] = { 1,3,6,1,3,112,1,3,100,4,1,57, /* insert index here */ };

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
        snmptrap_oid, OID_LENGTH(snmptrap_oid),
        ASN_OBJECT_ID,
        pgmNakFailuresTrap_oid, sizeof(pgmNakFailuresTrap_oid));
    
    /*
     * Add any objects from the trap definition
     */
    snmp_varlist_add_variable(&var_list,
        pgmReceiverSourceGsi_oid, OID_LENGTH(pgmReceiverSourceGsi_oid),
        ASN_OCTET_STR,
        /* Set an appropriate value for pgmReceiverSourceGsi */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmReceiverSourcePortNumber_oid, OID_LENGTH(pgmReceiverSourcePortNumber_oid),
        ASN_UNSIGNED,
        /* Set an appropriate value for pgmReceiverSourcePortNumber */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmReceiverUniqueInstance_oid, OID_LENGTH(pgmReceiverUniqueInstance_oid),
        ASN_UNSIGNED,
        /* Set an appropriate value for pgmReceiverUniqueInstance */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmReceiverNakFailureThresholdTimer_oid, OID_LENGTH(pgmReceiverNakFailureThresholdTimer_oid),
        ASN_UNSIGNED,
        /* Set an appropriate value for pgmReceiverNakFailureThresholdTimer */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmReceiverNakFailureThreshold_oid, OID_LENGTH(pgmReceiverNakFailureThreshold_oid),
        ASN_UNSIGNED,
        /* Set an appropriate value for pgmReceiverNakFailureThreshold */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmReceiverNakFailuresLastInterval_oid, OID_LENGTH(pgmReceiverNakFailuresLastInterval_oid),
        ASN_COUNTER,
        /* Set an appropriate value for pgmReceiverNakFailuresLastInterval */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmReceiverLastIntervalNakFailures_oid, OID_LENGTH(pgmReceiverLastIntervalNakFailures_oid),
        ASN_COUNTER,
        /* Set an appropriate value for pgmReceiverLastIntervalNakFailures */
        NULL, 0);

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap( var_list );
    snmp_free_varbind( var_list );

    return SNMP_ERR_NOERROR;
}
int
send_pgmNewDlrSourceTrap_trap( void )
{
    netsnmp_variable_list  *var_list = NULL;
    oid pgmNewDlrSourceTrap_oid[] = { 1,3,6,1,3,112,2,0,8 };
    oid pgmDlrSourceSourceGsi_oid[] = { 1,3,6,1,3,112,1,4,100,2,1,4, /* insert index here */ };
    oid pgmDlrSourceSourcePortNumber_oid[] = { 1,3,6,1,3,112,1,4,100,2,1,5, /* insert index here */ };

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
        snmptrap_oid, OID_LENGTH(snmptrap_oid),
        ASN_OBJECT_ID,
        pgmNewDlrSourceTrap_oid, sizeof(pgmNewDlrSourceTrap_oid));
    
    /*
     * Add any objects from the trap definition
     */
    snmp_varlist_add_variable(&var_list,
        pgmDlrSourceSourceGsi_oid, OID_LENGTH(pgmDlrSourceSourceGsi_oid),
        ASN_OCTET_STR,
        /* Set an appropriate value for pgmDlrSourceSourceGsi */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmDlrSourceSourcePortNumber_oid, OID_LENGTH(pgmDlrSourceSourcePortNumber_oid),
        ASN_UNSIGNED,
        /* Set an appropriate value for pgmDlrSourceSourcePortNumber */
        NULL, 0);

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap( var_list );
    snmp_free_varbind( var_list );

    return SNMP_ERR_NOERROR;
}
int
send_pgmClosedDlrSourceTrap_trap( void )
{
    netsnmp_variable_list  *var_list = NULL;
    oid pgmClosedDlrSourceTrap_oid[] = { 1,3,6,1,3,112,2,0,9 };
    oid pgmDlrSourceSourceGsi_oid[] = { 1,3,6,1,3,112,1,4,100,2,1,4, /* insert index here */ };
    oid pgmDlrSourceSourcePortNumber_oid[] = { 1,3,6,1,3,112,1,4,100,2,1,5, /* insert index here */ };

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
        snmptrap_oid, OID_LENGTH(snmptrap_oid),
        ASN_OBJECT_ID,
        pgmClosedDlrSourceTrap_oid, sizeof(pgmClosedDlrSourceTrap_oid));
    
    /*
     * Add any objects from the trap definition
     */
    snmp_varlist_add_variable(&var_list,
        pgmDlrSourceSourceGsi_oid, OID_LENGTH(pgmDlrSourceSourceGsi_oid),
        ASN_OCTET_STR,
        /* Set an appropriate value for pgmDlrSourceSourceGsi */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmDlrSourceSourcePortNumber_oid, OID_LENGTH(pgmDlrSourceSourcePortNumber_oid),
        ASN_UNSIGNED,
        /* Set an appropriate value for pgmDlrSourceSourcePortNumber */
        NULL, 0);

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap( var_list );
    snmp_free_varbind( var_list );

    return SNMP_ERR_NOERROR;
}
