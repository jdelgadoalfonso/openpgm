/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.notify.conf,v 5.3 2004/04/15 12:29:19 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include "pgm/pgmMIB.h"
#include "pgm/pgmMIB_columns.h"
#include "pgm/transport.h"


struct pgm_snmp_context_t {
	GSList* list;
};

typedef struct pgm_snmp_context_t pgm_snmp_context_t;


/* local globals */
static oid snmptrap_oid[] = {1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0};


/* functions */

static int initialize_table_pgmSourceTable(void);
static Netsnmp_Node_Handler pgmSourceTable_handler;
static Netsnmp_First_Data_Point pgmSourceTable_get_first_data_point;
static Netsnmp_Next_Data_Point pgmSourceTable_get_next_data_point;
static Netsnmp_Free_Loop_Context pgmSourceTable_free_loop_context;


int
pgm_mib_init (void)
{
	int retval = 0;

	retval = initialize_table_pgmSourceTable();
	if (retval != MIB_REGISTERED_OK) {
		g_error ("pgmSourceTable registration failed.");
		goto out;
	}

#if 0
	initialize_table_pgmSourceConfigTable();
	initialize_table_pgmSourcePerformanceTable();
	initialize_table_pgmReceiverTable();
	initialize_table_pgmReceiverConfigTable();
	initialize_table_pgmReceiverPerformanceTable();
#endif

out:
	return retval;
}

/*
 * pgmSourceTable
 *
 * returns MIB_REGISTERED_OK on success, failures include:
 * 	MIB_REGISTRATION_FAILED
 * 	MIB_DUPLICATE_REGISTRATION
 * 	SNMPERR_GENERR
 */

static int
initialize_table_pgmSourceTable(void)
{
	static oid pgmSourceTable_oid[] = {1,3,6,1,3,112,1,2,100,2};
	netsnmp_table_registration_info* table_info = NULL;
	netsnmp_iterator_info* iinfo = NULL;
	netsnmp_handler_registration* reg = NULL;

	reg = netsnmp_create_handler_registration(
						"pgmSourceTable",	pgmSourceTable_handler,
						pgmSourceTable_oid,	OID_LENGTH(pgmSourceTable_oid),
						HANDLER_CAN_RONLY
						);
	if (!reg)
		goto error;

	table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
	if (!table_info)
		goto error;

	table_info->min_column = COLUMN_PGMSOURCESOURCEADDRESS;
	table_info->max_column = COLUMN_PGMSOURCESOURCEPORTNUMBER;

	netsnmp_table_helper_add_indexes(table_info,
						ASN_OCTET_STR,  /* index: pgmSourceGlobalId */
						ASN_UNSIGNED,  /* index: pgmSourceSourcePort */
						0);

	iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
	if (!iinfo)
		goto error;

	iinfo->get_first_data_point = pgmSourceTable_get_first_data_point;
	iinfo->get_next_data_point  = pgmSourceTable_get_next_data_point;
	iinfo->free_loop_context_at_end = pgmSourceTable_free_loop_context;
	iinfo->table_reginfo        = table_info;

	return netsnmp_register_table_iterator( reg, iinfo );

error:
	if (table_info && table_info->indexes)		/* table_data_free_func() is internal */
		snmp_free_var(table_info->indexes);
	SNMP_FREE(table_info);
	SNMP_FREE(iinfo);
	netsnmp_handler_registration_free (reg);

	return -1;
}

/* called for first row of data in SNMP table
 *
 * goal is to cache all the relevant data for subsequent get_next_data_point (row) calls in my_loop_context,
 * optionally returns my_data_context.
 *
 * returns answer or NULL
 */

static netsnmp_variable_list*
pgmSourceTable_get_first_data_point(
	void**			my_loop_context,	/* valid through one query of multiple "data points" */
	void**			my_data_context,	/* answer blob which is passed to handler() */
	netsnmp_variable_list*	put_index_data,		/* answer */
	netsnmp_iterator_info*	mydata)			/* iinfo on init() */
{
	g_static_rw_lock_reader_lock (&pgm_transport_list_lock);

	if (pgm_transport_list == NULL) {
		g_static_rw_lock_reader_unlock (&pgm_transport_list_lock);
		return NULL;
	}

/* create our own context for this SNMP loop */
	pgm_snmp_context_t* context = g_malloc0 (sizeof(pgm_snmp_context_t));
	context->list = pgm_transport_list;
	*my_loop_context = context;

/* pass on for generic row access */
	return pgmSourceTable_get_next_data_point (my_loop_context, my_data_context, put_index_data, mydata);
}

static netsnmp_variable_list*
pgmSourceTable_get_next_data_point(
	void**			my_loop_context,
	void**			my_data_context,
	netsnmp_variable_list*	put_index_data,
	netsnmp_iterator_info*	mydata)
{
	pgm_snmp_context_t* context = (pgm_snmp_context_t*)*my_loop_context;
	netsnmp_variable_list *idx = put_index_data;

	if ( context->list )
	{
		pgm_transport_t* transport = context->list->data;

/* pgmSourceGlobalId */
		char gsi[sizeof("000" "000" "000" "000" "000" "000")];
		snprintf(gsi, sizeof(gsi), "%hhu%hhu%hhu%hhu%hhu%hhu",
			transport->tsi.gsi.identifier[0],
			transport->tsi.gsi.identifier[1],
			transport->tsi.gsi.identifier[2],
			transport->tsi.gsi.identifier[3],
			transport->tsi.gsi.identifier[4],
			transport->tsi.gsi.identifier[5]);
		snmp_set_var_typed_value( idx, ASN_OCTET_STR, (u_char*)&gsi, sizeof(gsi) );
		idx = idx->next_variable;

/* pgmSourceSourcePort */
		unsigned long sport = g_ntohs (transport->tsi.sport);
		snmp_set_var_typed_value( idx, ASN_UNSIGNED, (u_char*)&sport, sizeof(sport) );
		idx = idx->next_variable;

		*my_data_context = transport;
		context->list = context->list->next;
	} else {
		return NULL;
	}

	return put_index_data;
}

static void
pgmSourceTable_free_loop_context (
	void*			my_loop_context,
	netsnmp_iterator_info*	mydata)
{
	pgm_snmp_context_t* context = (pgm_snmp_context_t*)my_loop_context;
	g_free(context);
	my_loop_context = NULL;

	g_static_rw_lock_reader_unlock (&pgm_transport_list_lock);
}

static int
pgmSourceTable_handler (
	netsnmp_mib_handler*		handler,
	netsnmp_handler_registration*	reginfo,
	netsnmp_agent_request_info*	reqinfo,
	netsnmp_request_info*		requests)
{
	switch (reqinfo->mode)
	{

/* Read-support (also covers GetNext requests) */

	case MODE_GET:
		for (netsnmp_request_info* request=requests; request; request=request->next)
		{
			netsnmp_variable_list *var = request->requestvb;
			pgm_transport_t* transport = (pgm_transport_t*)netsnmp_extract_iterator_context(request);
			netsnmp_table_request_info* table_info = netsnmp_extract_table_info(request);

			switch (table_info->colnum)
			{
			case COLUMN_PGMSOURCESOURCEADDRESS:
				snmp_set_var_typed_value(	var, ASN_IPADDRESS,
								(u_char*)pgm_sockaddr_addr( &transport->send_smr.smr_interface ),
								pgm_sockaddr_len( &transport->send_smr.smr_interface ));
				break;

			case COLUMN_PGMSOURCEGROUPADDRESS:
				snmp_set_var_typed_value(	var, ASN_IPADDRESS,
								(u_char*)pgm_sockaddr_addr( &transport->send_smr.smr_multiaddr ),
								pgm_sockaddr_len( &transport->send_smr.smr_multiaddr ));
				break;

			case COLUMN_PGMSOURCEDESTPORT:
				{
				unsigned long dport = g_ntohs (transport->dport);
				snmp_set_var_typed_value(	var, ASN_UNSIGNED,
								(u_char*)&dport, sizeof(dport) );
				}
				break;

			case COLUMN_PGMSOURCESOURCEGSI:
/* copy index[0] */
				snmp_set_var_typed_value(	var, ASN_OCTET_STR,
								(u_char*)table_info->indexes->val.string,
								table_info->indexes->val_len);
				break;

			case COLUMN_PGMSOURCESOURCEPORTNUMBER:
/* copy index[1] */
				snmp_set_var_typed_value(	var, ASN_UNSIGNED,
								(u_char*)table_info->indexes->next_variable->val.integer,
								table_info->indexes->next_variable->val_len);
				break;

			default:
				snmp_log (LOG_ERR, "pgmSourceTable_handler: unknown column.\n");
				break;
			}
		}
		break;

	case MODE_SET_RESERVE1:
	default:
		snmp_log (LOG_ERR, "pgmSourceTable_handler: unsupported mode.\n");
		break;

	}

	return SNMP_ERR_NOERROR;
}

/*
 * SNMP TRAPS
 */

int
send_pgmStart_trap( void )
{
    netsnmp_variable_list  *var_list = NULL;
    oid pgmStart_oid[] = { 1,3,6,1,3,112,2,0,1 };

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
        snmptrap_oid, OID_LENGTH(snmptrap_oid),
        ASN_OBJECT_ID,
        pgmStart_oid, sizeof(pgmStart_oid));
    

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap( var_list );
    snmp_free_varbind( var_list );

    return SNMP_ERR_NOERROR;
}
int
send_pgmStop_trap( void )
{
    netsnmp_variable_list  *var_list = NULL;
    oid pgmStop_oid[] = { 1,3,6,1,3,112,2,0,2 };

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
        snmptrap_oid, OID_LENGTH(snmptrap_oid),
        ASN_OBJECT_ID,
        pgmStop_oid, sizeof(pgmStop_oid));
    

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap( var_list );
    snmp_free_varbind( var_list );

    return SNMP_ERR_NOERROR;
}
int
send_pgmNewSourceTrap_trap( void )
{
    netsnmp_variable_list  *var_list = NULL;
    oid pgmNewSourceTrap_oid[] = { 1,3,6,1,3,112,2,0,3 };
    oid pgmSourceSourceGsi_oid[] = { 1,3,6,1,3,112,1,2,100,2,1,6, /* insert index here */ };
    oid pgmSourceSourcePortNumber_oid[] = { 1,3,6,1,3,112,1,2,100,2,1,7, /* insert index here */ };

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
        snmptrap_oid, OID_LENGTH(snmptrap_oid),
        ASN_OBJECT_ID,
        pgmNewSourceTrap_oid, sizeof(pgmNewSourceTrap_oid));
    
    /*
     * Add any objects from the trap definition
     */
    snmp_varlist_add_variable(&var_list,
        pgmSourceSourceGsi_oid, OID_LENGTH(pgmSourceSourceGsi_oid),
        ASN_OCTET_STR,
        /* Set an appropriate value for pgmSourceSourceGsi */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmSourceSourcePortNumber_oid, OID_LENGTH(pgmSourceSourcePortNumber_oid),
        ASN_UNSIGNED,
        /* Set an appropriate value for pgmSourceSourcePortNumber */
        NULL, 0);

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap( var_list );
    snmp_free_varbind( var_list );

    return SNMP_ERR_NOERROR;
}
int
send_pgmClosedSourceTrap_trap( void )
{
    netsnmp_variable_list  *var_list = NULL;
    oid pgmClosedSourceTrap_oid[] = { 1,3,6,1,3,112,2,0,4 };
    oid pgmSourceSourceGsi_oid[] = { 1,3,6,1,3,112,1,2,100,2,1,6, /* insert index here */ };
    oid pgmSourceSourcePortNumber_oid[] = { 1,3,6,1,3,112,1,2,100,2,1,7, /* insert index here */ };

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
        snmptrap_oid, OID_LENGTH(snmptrap_oid),
        ASN_OBJECT_ID,
        pgmClosedSourceTrap_oid, sizeof(pgmClosedSourceTrap_oid));
    
    /*
     * Add any objects from the trap definition
     */
    snmp_varlist_add_variable(&var_list,
        pgmSourceSourceGsi_oid, OID_LENGTH(pgmSourceSourceGsi_oid),
        ASN_OCTET_STR,
        /* Set an appropriate value for pgmSourceSourceGsi */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmSourceSourcePortNumber_oid, OID_LENGTH(pgmSourceSourcePortNumber_oid),
        ASN_UNSIGNED,
        /* Set an appropriate value for pgmSourceSourcePortNumber */
        NULL, 0);

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap( var_list );
    snmp_free_varbind( var_list );

    return SNMP_ERR_NOERROR;
}
int
send_pgmNewReceiverTrap_trap( void )
{
    netsnmp_variable_list  *var_list = NULL;
    oid pgmNewReceiverTrap_oid[] = { 1,3,6,1,3,112,2,0,5 };
    oid pgmReceiverSourceGsi_oid[] = { 1,3,6,1,3,112,1,3,100,2,1,8, /* insert index here */ };
    oid pgmReceiverSourcePortNumber_oid[] = { 1,3,6,1,3,112,1,3,100,2,1,9, /* insert index here */ };
    oid pgmReceiverUniqueInstance_oid[] = { 1,3,6,1,3,112,1,3,100,2,1,10, /* insert index here */ };

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
        snmptrap_oid, OID_LENGTH(snmptrap_oid),
        ASN_OBJECT_ID,
        pgmNewReceiverTrap_oid, sizeof(pgmNewReceiverTrap_oid));
    
    /*
     * Add any objects from the trap definition
     */
    snmp_varlist_add_variable(&var_list,
        pgmReceiverSourceGsi_oid, OID_LENGTH(pgmReceiverSourceGsi_oid),
        ASN_OCTET_STR,
        /* Set an appropriate value for pgmReceiverSourceGsi */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmReceiverSourcePortNumber_oid, OID_LENGTH(pgmReceiverSourcePortNumber_oid),
        ASN_UNSIGNED,
        /* Set an appropriate value for pgmReceiverSourcePortNumber */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmReceiverUniqueInstance_oid, OID_LENGTH(pgmReceiverUniqueInstance_oid),
        ASN_UNSIGNED,
        /* Set an appropriate value for pgmReceiverUniqueInstance */
        NULL, 0);

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap( var_list );
    snmp_free_varbind( var_list );

    return SNMP_ERR_NOERROR;
}
int
send_pgmClosedReceiverTrap_trap( void )
{
    netsnmp_variable_list  *var_list = NULL;
    oid pgmClosedReceiverTrap_oid[] = { 1,3,6,1,3,112,2,0,6 };
    oid pgmReceiverSourceGsi_oid[] = { 1,3,6,1,3,112,1,3,100,2,1,8, /* insert index here */ };
    oid pgmReceiverSourcePortNumber_oid[] = { 1,3,6,1,3,112,1,3,100,2,1,9, /* insert index here */ };
    oid pgmReceiverUniqueInstance_oid[] = { 1,3,6,1,3,112,1,3,100,2,1,10, /* insert index here */ };

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
        snmptrap_oid, OID_LENGTH(snmptrap_oid),
        ASN_OBJECT_ID,
        pgmClosedReceiverTrap_oid, sizeof(pgmClosedReceiverTrap_oid));
    
    /*
     * Add any objects from the trap definition
     */
    snmp_varlist_add_variable(&var_list,
        pgmReceiverSourceGsi_oid, OID_LENGTH(pgmReceiverSourceGsi_oid),
        ASN_OCTET_STR,
        /* Set an appropriate value for pgmReceiverSourceGsi */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmReceiverSourcePortNumber_oid, OID_LENGTH(pgmReceiverSourcePortNumber_oid),
        ASN_UNSIGNED,
        /* Set an appropriate value for pgmReceiverSourcePortNumber */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmReceiverUniqueInstance_oid, OID_LENGTH(pgmReceiverUniqueInstance_oid),
        ASN_UNSIGNED,
        /* Set an appropriate value for pgmReceiverUniqueInstance */
        NULL, 0);

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap( var_list );
    snmp_free_varbind( var_list );

    return SNMP_ERR_NOERROR;
}
int
send_pgmNakFailuresTrap_trap( void )
{
    netsnmp_variable_list  *var_list = NULL;
    oid pgmNakFailuresTrap_oid[] = { 1,3,6,1,3,112,2,0,7 };
    oid pgmReceiverSourceGsi_oid[] = { 1,3,6,1,3,112,1,3,100,2,1,8, /* insert index here */ };
    oid pgmReceiverSourcePortNumber_oid[] = { 1,3,6,1,3,112,1,3,100,2,1,9, /* insert index here */ };
    oid pgmReceiverUniqueInstance_oid[] = { 1,3,6,1,3,112,1,3,100,2,1,10, /* insert index here */ };
    oid pgmReceiverNakFailureThresholdTimer_oid[] = { 1,3,6,1,3,112,1,3,100,3,1,14, /* insert index here */ };
    oid pgmReceiverNakFailureThreshold_oid[] = { 1,3,6,1,3,112,1,3,100,3,1,15, /* insert index here */ };
    oid pgmReceiverNakFailuresLastInterval_oid[] = { 1,3,6,1,3,112,1,3,100,4,1,56, /* insert index here */ };
    oid pgmReceiverLastIntervalNakFailures_oid[] = { 1,3,6,1,3,112,1,3,100,4,1,57, /* insert index here */ };

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
        snmptrap_oid, OID_LENGTH(snmptrap_oid),
        ASN_OBJECT_ID,
        pgmNakFailuresTrap_oid, sizeof(pgmNakFailuresTrap_oid));
    
    /*
     * Add any objects from the trap definition
     */
    snmp_varlist_add_variable(&var_list,
        pgmReceiverSourceGsi_oid, OID_LENGTH(pgmReceiverSourceGsi_oid),
        ASN_OCTET_STR,
        /* Set an appropriate value for pgmReceiverSourceGsi */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmReceiverSourcePortNumber_oid, OID_LENGTH(pgmReceiverSourcePortNumber_oid),
        ASN_UNSIGNED,
        /* Set an appropriate value for pgmReceiverSourcePortNumber */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmReceiverUniqueInstance_oid, OID_LENGTH(pgmReceiverUniqueInstance_oid),
        ASN_UNSIGNED,
        /* Set an appropriate value for pgmReceiverUniqueInstance */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmReceiverNakFailureThresholdTimer_oid, OID_LENGTH(pgmReceiverNakFailureThresholdTimer_oid),
        ASN_UNSIGNED,
        /* Set an appropriate value for pgmReceiverNakFailureThresholdTimer */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmReceiverNakFailureThreshold_oid, OID_LENGTH(pgmReceiverNakFailureThreshold_oid),
        ASN_UNSIGNED,
        /* Set an appropriate value for pgmReceiverNakFailureThreshold */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmReceiverNakFailuresLastInterval_oid, OID_LENGTH(pgmReceiverNakFailuresLastInterval_oid),
        ASN_COUNTER,
        /* Set an appropriate value for pgmReceiverNakFailuresLastInterval */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmReceiverLastIntervalNakFailures_oid, OID_LENGTH(pgmReceiverLastIntervalNakFailures_oid),
        ASN_COUNTER,
        /* Set an appropriate value for pgmReceiverLastIntervalNakFailures */
        NULL, 0);

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap( var_list );
    snmp_free_varbind( var_list );

    return SNMP_ERR_NOERROR;
}
int
send_pgmNewDlrSourceTrap_trap( void )
{
    netsnmp_variable_list  *var_list = NULL;
    oid pgmNewDlrSourceTrap_oid[] = { 1,3,6,1,3,112,2,0,8 };
    oid pgmDlrSourceSourceGsi_oid[] = { 1,3,6,1,3,112,1,4,100,2,1,4, /* insert index here */ };
    oid pgmDlrSourceSourcePortNumber_oid[] = { 1,3,6,1,3,112,1,4,100,2,1,5, /* insert index here */ };

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
        snmptrap_oid, OID_LENGTH(snmptrap_oid),
        ASN_OBJECT_ID,
        pgmNewDlrSourceTrap_oid, sizeof(pgmNewDlrSourceTrap_oid));
    
    /*
     * Add any objects from the trap definition
     */
    snmp_varlist_add_variable(&var_list,
        pgmDlrSourceSourceGsi_oid, OID_LENGTH(pgmDlrSourceSourceGsi_oid),
        ASN_OCTET_STR,
        /* Set an appropriate value for pgmDlrSourceSourceGsi */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmDlrSourceSourcePortNumber_oid, OID_LENGTH(pgmDlrSourceSourcePortNumber_oid),
        ASN_UNSIGNED,
        /* Set an appropriate value for pgmDlrSourceSourcePortNumber */
        NULL, 0);

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap( var_list );
    snmp_free_varbind( var_list );

    return SNMP_ERR_NOERROR;
}
int
send_pgmClosedDlrSourceTrap_trap( void )
{
    netsnmp_variable_list  *var_list = NULL;
    oid pgmClosedDlrSourceTrap_oid[] = { 1,3,6,1,3,112,2,0,9 };
    oid pgmDlrSourceSourceGsi_oid[] = { 1,3,6,1,3,112,1,4,100,2,1,4, /* insert index here */ };
    oid pgmDlrSourceSourcePortNumber_oid[] = { 1,3,6,1,3,112,1,4,100,2,1,5, /* insert index here */ };

    /*
     * Set the snmpTrapOid.0 value
     */
    snmp_varlist_add_variable(&var_list,
        snmptrap_oid, OID_LENGTH(snmptrap_oid),
        ASN_OBJECT_ID,
        pgmClosedDlrSourceTrap_oid, sizeof(pgmClosedDlrSourceTrap_oid));
    
    /*
     * Add any objects from the trap definition
     */
    snmp_varlist_add_variable(&var_list,
        pgmDlrSourceSourceGsi_oid, OID_LENGTH(pgmDlrSourceSourceGsi_oid),
        ASN_OCTET_STR,
        /* Set an appropriate value for pgmDlrSourceSourceGsi */
        NULL, 0);
    snmp_varlist_add_variable(&var_list,
        pgmDlrSourceSourcePortNumber_oid, OID_LENGTH(pgmDlrSourceSourcePortNumber_oid),
        ASN_UNSIGNED,
        /* Set an appropriate value for pgmDlrSourceSourcePortNumber */
        NULL, 0);

    /*
     * Add any extra (optional) objects here
     */

    /*
     * Send the trap to the list of configured destinations
     *  and clean up
     */
    send_v2trap( var_list );
    snmp_free_varbind( var_list );

    return SNMP_ERR_NOERROR;
}
