--- getifaddrs.c	2010-07-03 20:31:27.000000000 +0800
+++ getifaddrs.c89	2010-08-04 10:49:52.000000000 +0800
@@ -507,7 +507,9 @@
 /* loop to handle interfaces coming online causing a buffer overflow
  * between first call to list buffer length and second call to enumerate.
  */
-	for (unsigned i = MAX_TRIES; i; i--)
+	{
+	unsigned i;
+	for (i = MAX_TRIES; i; i--)
 	{
 		pgm_debug ("IP_ADAPTER_INFO buffer length %lu bytes.", ulOutBufLen);
 		pAdapterInfo = (IP_ADAPTER_INFO*)_pgm_heap_alloc (ulOutBufLen);
@@ -519,6 +521,7 @@
 			break;
 		}
 	}
+	}
 
 	switch (dwRet) {
 	case ERROR_SUCCESS:	/* NO_ERROR */
@@ -543,12 +546,15 @@
 	}
 
 /* count valid adapters */
+	{
 	int n = 0, k = 0;
 	for (pAdapter = pAdapterInfo;
 		 pAdapter;
 		 pAdapter = pAdapter->Next)
 	{
-		for (IP_ADDR_STRING *pIPAddr = &pAdapter->IpAddressList;
+		{
+		IP_ADDR_STRING *pIPAddr;
+		for (pIPAddr = &pAdapter->IpAddressList;
 			 pIPAddr;
 			 pIPAddr = pIPAddr->Next)
 		{
@@ -557,11 +563,13 @@
 				continue;
 			++n;
 		}
+		}
 	}
 
 	pgm_debug ("GetAdaptersInfo() discovered %d interfaces.", n);
 
 /* contiguous block for adapter list */
+	{
 	struct _pgm_ifaddrs_t* ifa = pgm_new0 (struct _pgm_ifaddrs_t, n);
 	struct _pgm_ifaddrs_t* ift = ifa;
 
@@ -570,7 +578,9 @@
 		 pAdapter;
 		 pAdapter = pAdapter->Next)
 	{
-		for (IP_ADDR_STRING *pIPAddr = &pAdapter->IpAddressList;
+		{
+		IP_ADDR_STRING *pIPAddr;
+		for (pIPAddr = &pAdapter->IpAddressList;
 			 pIPAddr;
 			 pIPAddr = pIPAddr->Next)
 		{
@@ -586,8 +596,12 @@
 			pgm_debug ("name:%s IPv4 index:%lu",
 				pAdapter->AdapterName, pAdapter->Index);
 			ift->_ifa.ifa_name = ift->_name;
+#ifdef _MSC_VER
+			strncpy_s (ift->_ifa.ifa_name, IF_NAMESIZE, pAdapter->AdapterName, _TRUNCATE);
+#else
 			strncpy (ift->_ifa.ifa_name, pAdapter->AdapterName, IF_NAMESIZE);
 			ift->_ifa.ifa_name[IF_NAMESIZE - 1] = 0;
+#endif
 
 /* flags: assume up, broadcast and multicast */
 			ift->_ifa.ifa_flags = IFF_UP | IFF_BROADCAST | IFF_MULTICAST;
@@ -604,11 +618,14 @@
 				ift = (struct _pgm_ifaddrs_t*)(ift->_ifa.ifa_next);
 			}
 		}
+		}
 	}
 
 	if (pAdapterInfo)
 		free (pAdapterInfo);
 	*ifap = (struct pgm_ifaddrs_t*)ifa;
+	}
+	}
 	return TRUE;
 }
 
@@ -625,7 +642,9 @@
 /* loop to handle interfaces coming online causing a buffer overflow
  * between first call to list buffer length and second call to enumerate.
  */
-	for (unsigned i = MAX_TRIES; i; i--)
+	{
+	unsigned i;
+	for (i = MAX_TRIES; i; i--)
 	{
 		pgm_debug ("IP_ADAPTER_ADDRESSES buffer length %lu bytes.", dwSize);
 		pAdapterAddresses = (IP_ADAPTER_ADDRESSES*)_pgm_heap_alloc (dwSize);
@@ -645,6 +664,7 @@
 			break;
 		}
 	}
+	}
 
 	switch (dwRet) {
 	case ERROR_SUCCESS:
@@ -669,12 +689,15 @@
 	}
 
 /* count valid adapters */
+	{
 	int n = 0, k = 0;
 	for (adapter = pAdapterAddresses;
 		 adapter;
 		 adapter = adapter->Next)
 	{
-		for (IP_ADAPTER_UNICAST_ADDRESS *unicast = adapter->FirstUnicastAddress;
+		{
+		IP_ADAPTER_UNICAST_ADDRESS *unicast;
+		for (unicast = adapter->FirstUnicastAddress;
 			 unicast;
 			 unicast = unicast->Next)
 		{
@@ -687,9 +710,11 @@
 
 			++n;
 		}
+		}
 	}
 
 /* contiguous block for adapter list */
+	{
 	struct _pgm_ifaddrs_t* ifa = pgm_new0 (struct _pgm_ifaddrs_t, n);
 	struct _pgm_ifaddrs_t* ift = ifa;
 
@@ -699,7 +724,9 @@
 		 adapter = adapter->Next)
 	{
 		int unicastIndex = 0;
-		for (IP_ADAPTER_UNICAST_ADDRESS *unicast = adapter->FirstUnicastAddress;
+		{
+		IP_ADAPTER_UNICAST_ADDRESS *unicast;
+		for (unicast = adapter->FirstUnicastAddress;
 			 unicast;
 			 unicast = unicast->Next, ++unicastIndex)
 		{
@@ -718,8 +745,12 @@
 			pgm_debug ("name:%s IPv4 index:%lu IPv6 index:%lu",
 				adapter->AdapterName, adapter->IfIndex, adapter->Ipv6IfIndex);
 			ift->_ifa.ifa_name = ift->_name;
+#ifdef _MSC_VER
+			strncpy_s (ift->_ifa.ifa_name, IF_NAMESIZE, adapter->AdapterName, _TRUNCATE);
+#else
 			strncpy (ift->_ifa.ifa_name, adapter->AdapterName, IF_NAMESIZE);
 			ift->_ifa.ifa_name[IF_NAMESIZE - 1] = 0;
+#endif
 
 /* flags */
 			ift->_ifa.ifa_flags = 0;
@@ -734,9 +765,12 @@
 			ift->_ifa.ifa_netmask = (void*)&ift->_netmask;
 
 /* pre-Vista must hunt for matching prefix in linked list, otherwise use OnLinkPrefixLength */
+			{
 			int prefixIndex = 0;
 			ULONG prefixLength = 0;
-			for (IP_ADAPTER_PREFIX *prefix = adapter->FirstPrefix;
+			{
+			IP_ADAPTER_PREFIX *prefix;
+			for (prefix = adapter->FirstPrefix;
 				prefix;
 				prefix = prefix->Next, ++prefixIndex)
 			{
@@ -745,6 +779,7 @@
 					break;
 				}
 			}
+			}
 
 /* map prefix to netmask */
 			ift->_ifa.ifa_netmask->sa_family = unicast->Address.lpSockaddr->sa_family;
@@ -762,12 +797,16 @@
 					pgm_warn (_("IPv6 adapter %s prefix length is 0, overriding to 128."), adapter->AdapterName);
 					prefixLength = 128;
 				}
-				for (ULONG i = prefixLength, j = 0; i > 0; i -= 8, ++j)
+				{
+				ULONG i, j;
+				for (i = prefixLength, j = 0; i > 0; i -= 8, ++j)
 				{
 					((struct sockaddr_in6*)ift->_ifa.ifa_netmask)->sin6_addr.s6_addr[ j ] = i >= 8 ? 0xff : (ULONG)(( 0xffU << ( 8 - i ) ) & 0xffU );
 				}
+				}
 				break;
 			}
+			}
 
 /* next */
 			if (k++ < (n - 1)) {
@@ -775,11 +814,14 @@
 				ift = (struct _pgm_ifaddrs_t*)(ift->_ifa.ifa_next);
 			}
 		}
+		}
 	}
 
 	if (pAdapterAddresses)
 		free (pAdapterAddresses);
 	*ifap = (struct pgm_ifaddrs_t*)ifa;
+	}
+	}
 	return TRUE;
 }
 #endif /* _WIN32 */
