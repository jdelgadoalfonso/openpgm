--- getifaddrs.c	2011-07-06 05:28:07.000000000 +0800
+++ getifaddrs.c89.c	2011-07-06 05:29:58.000000000 +0800
@@ -576,7 +576,9 @@
 /* loop to handle interfaces coming online causing a buffer overflow
  * between first call to list buffer length and second call to enumerate.
  */
-	for (unsigned i = MAX_TRIES; i; i--)
+	{
+	unsigned i;
+	for (i = MAX_TRIES; i; i--)
 	{
 		pgm_debug ("IP_ADAPTER_INFO buffer length %lu bytes.", ulOutBufLen);
 		pAdapterInfo = (IP_ADAPTER_INFO*)_pgm_heap_alloc (ulOutBufLen);
@@ -588,6 +590,7 @@
 			break;
 		}
 	}
+	}
 
 	switch (dwRet) {
 	case ERROR_SUCCESS:	/* NO_ERROR */
@@ -612,12 +615,15 @@
 	}
 
 /* count valid adapters */
+	{
 	int n = 0, k = 0;
 	for (pAdapter = pAdapterInfo;
 		 pAdapter;
 		 pAdapter = pAdapter->Next)
 	{
-		for (IP_ADDR_STRING *pIPAddr = &pAdapter->IpAddressList;
+	{
+	IP_ADDR_STRING *pIPAddr;
+	for (pIPAddr = &pAdapter->IpAddressList;
 			 pIPAddr;
 			 pIPAddr = pIPAddr->Next)
 		{
@@ -627,10 +633,12 @@
 			++n;
 		}
 	}
+	}
 
 	pgm_debug ("GetAdaptersInfo() discovered %d interfaces.", n);
 
 /* contiguous block for adapter list */
+	{
 	struct _pgm_ifaddrs_t* ifa = pgm_new0 (struct _pgm_ifaddrs_t, n);
 	struct _pgm_ifaddrs_t* ift = ifa;
 
@@ -639,7 +647,9 @@
 		 pAdapter;
 		 pAdapter = pAdapter->Next)
 	{
-		for (IP_ADDR_STRING *pIPAddr = &pAdapter->IpAddressList;
+		{
+		IP_ADDR_STRING *pIPAddr;
+		for (pIPAddr = &pAdapter->IpAddressList;
 			 pIPAddr;
 			 pIPAddr = pIPAddr->Next)
 		{
@@ -672,11 +682,14 @@
 				ift = (struct _pgm_ifaddrs_t*)(ift->_ifa.ifa_next);
 			}
 		}
+		}
 	}
 
 	if (pAdapterInfo)
 		_pgm_heap_free (pAdapterInfo);
 	*ifap = (struct pgm_ifaddrs_t*)ifa;
+	}
+	}
 	return TRUE;
 }
 
@@ -699,12 +712,13 @@
 /* loop to handle interfaces coming online causing a buffer overflow
  * between first call to list buffer length and second call to enumerate.
  */
-	for (unsigned i = MAX_TRIES; i; i--)
+	{
+	unsigned i;
+	for (i = MAX_TRIES; i; i--)
 	{
 		pgm_debug ("IP_ADAPTER_ADDRESSES buffer length %lu bytes.", dwSize);
 		pAdapterAddresses = (IP_ADAPTER_ADDRESSES*)_pgm_heap_alloc (dwSize);
 		dwRet = GetAdaptersAddresses (AF_UNSPEC,
-/* requires Windows XP SP1 */
 						GAA_FLAG_INCLUDE_PREFIX |
 						GAA_FLAG_SKIP_ANYCAST |
 						GAA_FLAG_SKIP_DNS_SERVER |
@@ -720,6 +734,7 @@
 			break;
 		}
 	}
+	}
 
 	switch (dwRet) {
 	case ERROR_SUCCESS:
@@ -744,12 +759,15 @@
 	}
 
 /* count valid adapters */
+	{
 	int n = 0, k = 0;
 	for (adapter = pAdapterAddresses;
 		 adapter;
 		 adapter = adapter->Next)
 	{
-		for (IP_ADAPTER_UNICAST_ADDRESS *unicast = adapter->FirstUnicastAddress;
+		{
+		IP_ADAPTER_UNICAST_ADDRESS *unicast;
+		for (unicast = adapter->FirstUnicastAddress;
 			 unicast;
 			 unicast = unicast->Next)
 		{
@@ -762,9 +780,11 @@
 
 			++n;
 		}
+		}
 	}
 
 /* contiguous block for adapter list */
+	{
 	struct _pgm_ifaddrs_t* ifa = pgm_new0 (struct _pgm_ifaddrs_t, n);
 	struct _pgm_ifaddrs_t* ift = ifa;
 
@@ -774,7 +794,9 @@
 		 adapter = adapter->Next)
 	{
 		int unicastIndex = 0;
-		for (IP_ADAPTER_UNICAST_ADDRESS *unicast = adapter->FirstUnicastAddress;
+		{
+		IP_ADAPTER_UNICAST_ADDRESS *unicast;
+		for (unicast = adapter->FirstUnicastAddress;
 			 unicast;
 			 unicast = unicast->Next, ++unicastIndex)
 		{
@@ -890,7 +912,7 @@
 
 #define IN_LINKLOCAL(a)	((((uint32_t) (a)) & 0xaffff0000) == 0xa9fe0000)
 
-			for (IP_ADAPTER_PREFIX *prefix = adapter->FirstPrefix;
+			for (prefix = adapter->FirstPrefix;
 				prefix;
 				prefix = prefix->Next)
 			{
@@ -933,7 +955,7 @@
 				prefixLength = prefix->PrefixLength;
 				break;
 			}
- 			}
+			}
 #endif /* defined( _WIN32 ) && ( _WIN32_WINNT >= 0x0600 ) */
 
 /* map prefix to netmask */
@@ -965,12 +987,16 @@
 						prefixLength);
 					prefixLength = 128;
 				}
-				for (ULONG i = prefixLength, j = 0; i > 0; i -= 8, ++j)
+				{
+				ULONG i, j;
+				for (i = prefixLength, j = 0; i > 0; i -= 8, ++j)
 				{
 					((struct sockaddr_in6*)ift->_ifa.ifa_netmask)->sin6_addr.s6_addr[ j ] = i >= 8 ? 0xff : (ULONG)(( 0xffU << ( 8 - i ) ) & 0xffU );
 				}
+				}
 				break;
 			}
+			}
 
 /* next */
 			if (k++ < (n - 1)) {
@@ -978,11 +1004,14 @@
 				ift = (struct _pgm_ifaddrs_t*)(ift->_ifa.ifa_next);
 			}
 		}
+		}
 	}
 
 	if (pAdapterAddresses)
 		_pgm_heap_free (pAdapterAddresses);
 	*ifap = (struct pgm_ifaddrs_t*)ifa;
+	}
+	}
 	return TRUE;
 }
 #endif /* _WIN32 */
