--- getifaddrs.c	2010-10-07 16:00:42.000000000 +0800
+++ getifaddrs.c89	2010-10-07 16:01:33.000000000 +0800
@@ -519,7 +519,9 @@
 /* loop to handle interfaces coming online causing a buffer overflow
  * between first call to list buffer length and second call to enumerate.
  */
-	for (unsigned i = MAX_TRIES; i; i--)
+	{
+	unsigned i;
+	for (i = MAX_TRIES; i; i--)
 	{
 		pgm_debug ("IP_ADAPTER_INFO buffer length %lu bytes.", ulOutBufLen);
 		pAdapterInfo = (IP_ADAPTER_INFO*)_pgm_heap_alloc (ulOutBufLen);
@@ -531,6 +533,7 @@
 			break;
 		}
 	}
+	}
 
 	switch (dwRet) {
 	case ERROR_SUCCESS:	/* NO_ERROR */
@@ -555,12 +558,15 @@
 	}
 
 /* count valid adapters */
+	{
 	int n = 0, k = 0;
 	for (pAdapter = pAdapterInfo;
 		 pAdapter;
 		 pAdapter = pAdapter->Next)
 	{
-		for (IP_ADDR_STRING *pIPAddr = &pAdapter->IpAddressList;
+	{
+	IP_ADDR_STRING *pIPAddr;
+	for (pIPAddr = &pAdapter->IpAddressList;
 			 pIPAddr;
 			 pIPAddr = pIPAddr->Next)
 		{
@@ -570,10 +576,12 @@
 			++n;
 		}
 	}
+	}
 
 	pgm_debug ("GetAdaptersInfo() discovered %d interfaces.", n);
 
 /* contiguous block for adapter list */
+	{
 	struct _pgm_ifaddrs_t* ifa = pgm_new0 (struct _pgm_ifaddrs_t, n);
 	struct _pgm_ifaddrs_t* ift = ifa;
 
@@ -582,7 +590,9 @@
 		 pAdapter;
 		 pAdapter = pAdapter->Next)
 	{
-		for (IP_ADDR_STRING *pIPAddr = &pAdapter->IpAddressList;
+		{
+		IP_ADDR_STRING *pIPAddr;
+		for (pIPAddr = &pAdapter->IpAddressList;
 			 pIPAddr;
 			 pIPAddr = pIPAddr->Next)
 		{
@@ -615,11 +625,14 @@
 				ift = (struct _pgm_ifaddrs_t*)(ift->_ifa.ifa_next);
 			}
 		}
+		}
 	}
 
 	if (pAdapterInfo)
 		free (pAdapterInfo);
 	*ifap = (struct pgm_ifaddrs_t*)ifa;
+	}
+	}
 	return TRUE;
 }
 
@@ -636,7 +649,9 @@
 /* loop to handle interfaces coming online causing a buffer overflow
  * between first call to list buffer length and second call to enumerate.
  */
-	for (unsigned i = MAX_TRIES; i; i--)
+	{
+	unsigned i;
+	for (i = MAX_TRIES; i; i--)
 	{
 		pgm_debug ("IP_ADAPTER_ADDRESSES buffer length %lu bytes.", dwSize);
 		pAdapterAddresses = (IP_ADAPTER_ADDRESSES*)_pgm_heap_alloc (dwSize);
@@ -656,6 +671,7 @@
 			break;
 		}
 	}
+	}
 
 	switch (dwRet) {
 	case ERROR_SUCCESS:
@@ -680,12 +696,15 @@
 	}
 
 /* count valid adapters */
+	{
 	int n = 0, k = 0;
 	for (adapter = pAdapterAddresses;
 		 adapter;
 		 adapter = adapter->Next)
 	{
-		for (IP_ADAPTER_UNICAST_ADDRESS *unicast = adapter->FirstUnicastAddress;
+		{
+		IP_ADAPTER_UNICAST_ADDRESS *unicast;
+		for (unicast = adapter->FirstUnicastAddress;
 			 unicast;
 			 unicast = unicast->Next)
 		{
@@ -698,9 +717,11 @@
 
 			++n;
 		}
+		}
 	}
 
 /* contiguous block for adapter list */
+	{
 	struct _pgm_ifaddrs_t* ifa = pgm_new0 (struct _pgm_ifaddrs_t, n);
 	struct _pgm_ifaddrs_t* ift = ifa;
 
@@ -710,7 +731,9 @@
 		 adapter = adapter->Next)
 	{
 		int unicastIndex = 0;
-		for (IP_ADAPTER_UNICAST_ADDRESS *unicast = adapter->FirstUnicastAddress;
+		{
+		IP_ADAPTER_UNICAST_ADDRESS *unicast;
+		for (unicast = adapter->FirstUnicastAddress;
 			 unicast;
 			 unicast = unicast->Next, ++unicastIndex)
 		{
@@ -744,9 +767,12 @@
 			ift->_ifa.ifa_netmask = (void*)&ift->_netmask;
 
 /* pre-Vista must hunt for matching prefix in linked list, otherwise use OnLinkPrefixLength */
+			{
 			int prefixIndex = 0;
 			ULONG prefixLength = 0;
-			for (IP_ADAPTER_PREFIX *prefix = adapter->FirstPrefix;
+			{
+			IP_ADAPTER_PREFIX *prefix;
+			for (prefix = adapter->FirstPrefix;
 				prefix;
 				prefix = prefix->Next, ++prefixIndex)
 			{
@@ -755,6 +781,7 @@
 					break;
 				}
 			}
+			}
 
 /* map prefix to netmask */
 			ift->_ifa.ifa_netmask->sa_family = unicast->Address.lpSockaddr->sa_family;
@@ -772,12 +799,16 @@
 					pgm_warn (_("IPv6 adapter %s prefix length is 0, overriding to 128."), adapter->AdapterName);
 					prefixLength = 128;
 				}
-				for (ULONG i = prefixLength, j = 0; i > 0; i -= 8, ++j)
+				{
+				ULONG i, j;
+				for (i = prefixLength, j = 0; i > 0; i -= 8, ++j)
 				{
 					((struct sockaddr_in6*)ift->_ifa.ifa_netmask)->sin6_addr.s6_addr[ j ] = i >= 8 ? 0xff : (ULONG)(( 0xffU << ( 8 - i ) ) & 0xffU );
 				}
+				}
 				break;
 			}
+			}
 
 /* next */
 			if (k++ < (n - 1)) {
@@ -785,11 +816,14 @@
 				ift = (struct _pgm_ifaddrs_t*)(ift->_ifa.ifa_next);
 			}
 		}
+		}
 	}
 
 	if (pAdapterAddresses)
 		free (pAdapterAddresses);
 	*ifap = (struct pgm_ifaddrs_t*)ifa;
+	}
+	}
 	return TRUE;
 }
 #endif /* _WIN32 */
