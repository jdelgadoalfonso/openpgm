--- txw.c	2010-10-12 13:38:17.000000000 +0800
+++ txw.c89.c	2010-10-12 13:37:11.000000000 +0800
@@ -186,14 +186,15 @@
 		pgm_assert_cmpuint (rs_k, >, 0);
 	}
 
-	pgm_debug ("create (tsi:%s max-tpdu:%" PRIu16 " sqns:%" PRIu32  " secs %u max-rte %ld use-fec:%s rs(n):%u rs(k):%u)",
+	pgm_debug ("create (tsi:%s max-tpdu:%" PRIu16 " sqns:%" PRIu32  " secs %u max-rte %zd use-fec:%s rs(n):%u rs(k):%u)",
 		pgm_tsi_print (tsi),
-		tpdu_size, sqns, secs, (long)max_rte,
+		tpdu_size, sqns, secs, max_rte,
 		use_fec ? "YES" : "NO",
 		rs_n, rs_k);
 
 /* calculate transmit window parameters */
 	pgm_assert (sqns || (tpdu_size && secs && max_rte));
+	{
 	const unsigned alloc_sqns = sqns ? sqns : ( (secs * max_rte) / tpdu_size );
 	window = pgm_malloc0 (sizeof(pgm_txw_t) + ( alloc_sqns * sizeof(struct pgm_sk_buff_t*) ));
 	window->tsi = tsi;
@@ -225,6 +226,7 @@
 	pgm_assert (!pgm_txw_retransmit_can_peek (window));
 
 	return window;
+	}
 }
 
 /* destructor for transmit window.  must not be called more than once for same window.
@@ -310,8 +312,10 @@
 	skb->sequence = window->lead;
 
 /* add skb to window */
+	{
 	const uint_fast32_t index_ = skb->sequence % pgm_txw_max_length (window);
 	window->pdata[index_] = skb;
+	}
 
 /* statistics */
 	window->size += skb->len;
@@ -446,6 +450,7 @@
 	pgm_assert (NULL != window);
 	pgm_assert_cmpuint (tg_sqn_shift, <, 8 * sizeof(uint32_t));
 
+	{
 	const uint32_t tg_sqn_mask = 0xffffffff << tg_sqn_shift;
 	const uint32_t nak_tg_sqn  = sequence &  tg_sqn_mask;	/* left unshifted */
 	const uint32_t nak_pkt_cnt = sequence & ~tg_sqn_mask;
@@ -484,6 +489,7 @@
 	pgm_assert (!pgm_queue_is_empty (&window->retransmit_queue));
 	state->waiting_retransmit = 1;
 	return TRUE;
+	}
 }
 
 static
@@ -573,10 +579,13 @@
 	}
 
 /* generate parity packet to satisify request */	
+	{
 	const uint8_t rs_h = state->pkt_cnt_sent % (window->rs.n - window->rs.k);
 	const uint32_t tg_sqn_mask = 0xffffffff << window->tg_sqn_shift;
 	const uint32_t tg_sqn = skb->sequence & tg_sqn_mask;
-	for (uint_fast8_t i = 0; i < window->rs.k; i++)
+	{
+	uint_fast8_t i;
+	for (i = 0; i < window->rs.k; i++)
 	{
 		const struct pgm_sk_buff_t* odata_skb = pgm_txw_peek (window, tg_sqn + i);
 		const uint16_t odata_tsdu_length = ntohs (odata_skb->pgm_header->pgm_tsdu_length);
@@ -596,6 +605,7 @@
 			is_op_encoded = TRUE;
 		}
 	}
+	}
 
 /* construct basic PGM header to be completed by send_rdata() */
 	skb = window->parity_buffer;
@@ -655,7 +665,9 @@
 		memset (&null_opt_fragment, 0, sizeof(null_opt_fragment));
 		*(uint8_t*)&null_opt_fragment |= PGM_OP_ENCODED_NULL;
 
-		for (uint_fast8_t i = 0; i < window->rs.k; i++)
+		{
+		uint_fast8_t i;
+		for (i = 0; i < window->rs.k; i++)
 		{
 			const struct pgm_sk_buff_t* odata_skb = pgm_txw_peek (window, tg_sqn + i);
 
@@ -670,8 +682,10 @@
 				opt_src[i] = (pgm_gf8_t*)&null_opt_fragment;
 			}
 		}
+		}
 
 /* add options to this rdata packet */
+		{
 		const uint16_t opt_total_length = sizeof(struct pgm_opt_length) +
 						 sizeof(struct pgm_opt_header) +
 						 sizeof(struct pgm_opt_fragment);
@@ -683,6 +697,7 @@
 		opt_len->opt_type			= PGM_OPT_LENGTH;
 		opt_len->opt_length			= sizeof(struct pgm_opt_length);
 		opt_len->opt_total_length		= htons ( opt_total_length );
+		}
 		opt_header			 	= (struct pgm_opt_header*)(opt_len + 1);
 		opt_header->opt_type			= PGM_OPT_FRAGMENT | PGM_OPT_END;
 		opt_header->opt_length			= sizeof(struct pgm_opt_header) + sizeof(struct pgm_opt_fragment);
@@ -711,8 +726,10 @@
 			parity_length);
 
 /* calculate partial checksum */
+	{
 	const uint16_t tsdu_length = ntohs (skb->pgm_header->pgm_tsdu_length);
 	state->unfolded_checksum = pgm_csum_partial ((char*)skb->tail - tsdu_length, tsdu_length, 0);
+	}
 	return skb;
 }
 
