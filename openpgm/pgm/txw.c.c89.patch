--- txw.c	2010-08-05 11:07:09.000000000 +0800
+++ txw.c89	2010-08-05 11:11:36.000000000 +0800
@@ -192,7 +192,7 @@
 		pgm_assert_cmpuint (rs_k, >, 0);
 	}
 
-	pgm_debug ("create (tsi:%s max-tpdu:%" PRIu16 " sqns:%" PRIu32  " secs %u max-rte %zd use-fec:%s rs(n):%u rs(k):%u)",
+	pgm_debug ("create (tsi:%s max-tpdu:%" PRIu16 " sqns:%" PRIu32  " secs %u max-rte %ld use-fec:%s rs(n):%u rs(k):%u)",
 		pgm_tsi_print (tsi),
 		tpdu_size, sqns, secs, max_rte,
 		use_fec ? "YES" : "NO",
@@ -200,6 +200,7 @@
 
 /* calculate transmit window parameters */
 	pgm_assert (sqns || (tpdu_size && secs && max_rte));
+	{
 	const unsigned alloc_sqns = sqns ? sqns : ( (secs * max_rte) / tpdu_size );
 	window = pgm_malloc0 (sizeof(pgm_txw_t) + ( alloc_sqns * sizeof(struct pgm_sk_buff_t*) ));
 	window->tsi = tsi;
@@ -231,6 +232,7 @@
 	pgm_assert (!pgm_txw_retransmit_can_peek (window));
 
 	return window;
+	}
 }
 
 /* destructor for transmit window.  must not be called more than once for same window.
@@ -316,6 +318,7 @@
 	skb->sequence = window->lead;
 
 /* add skb to window */
+	{
 	const uint_fast32_t index_ = skb->sequence % pgm_txw_max_length (window);
 	window->pdata[index_] = skb;
 
@@ -325,6 +328,7 @@
 /* post-conditions */
 	pgm_assert_cmpuint (pgm_txw_length (window), >, 0);
 	pgm_assert_cmpuint (pgm_txw_length (window), <=, pgm_txw_max_length (window));
+	}
 }
 
 /* peek an entry from the window for retransmission.
@@ -452,6 +456,7 @@
 	pgm_assert (NULL != window);
 	pgm_assert_cmpuint (tg_sqn_shift, <, 8 * sizeof(uint32_t));
 
+	{
 	const uint32_t tg_sqn_mask = 0xffffffff << tg_sqn_shift;
 	const uint32_t nak_tg_sqn  = sequence &  tg_sqn_mask;	/* left unshifted */
 	const uint32_t nak_pkt_cnt = sequence & ~tg_sqn_mask;
@@ -490,6 +495,7 @@
 	pgm_assert (!pgm_queue_is_empty (&window->retransmit_queue));
 	state->waiting_retransmit = 1;
 	return TRUE;
+	}
 }
 
 static
@@ -548,14 +554,17 @@
 	pgm_debug ("retransmit_try_peek (window:%p)", (const void*)window);
 
 /* no lock required to detect presence of a request */
+	{
 	pgm_list_t* tail_link = pgm_queue_peek_tail_link (&window->retransmit_queue);
 	if (PGM_UNLIKELY(NULL == tail_link)) {
 		pgm_debug ("retransmit queue empty on peek.");
 		return NULL;
 	}
 
+	{
 	struct pgm_sk_buff_t* skb = (struct pgm_sk_buff_t*)tail_link;
 	pgm_assert (pgm_skb_is_valid (skb));
+	{
 	pgm_txw_state_t* state = (pgm_txw_state_t*)&skb->cb;
 
 	if (!state->waiting_retransmit) {
@@ -572,14 +581,17 @@
 	}
 
 /* generate parity packet to satisify request */	
+	{
 	const uint8_t rs_h = state->pkt_cnt_sent % (window->rs.n - window->rs.k);
 	const uint32_t tg_sqn_mask = 0xffffffff << window->tg_sqn_shift;
 	const uint32_t tg_sqn = skb->sequence & tg_sqn_mask;
 	bool is_var_pktlen = FALSE;
 	bool is_op_encoded = FALSE;
 	uint16_t parity_length = 0;
-	const pgm_gf8_t* src[ window->rs.k ];
-	for (uint_fast8_t i = 0; i < window->rs.k; i++)
+	const pgm_gf8_t** src = pgm_newa (pgm_gf8_t*, window->rs.k);
+	{
+	uint_fast8_t i;
+	for (i = 0; i < window->rs.k; i++)
 	{
 		const struct pgm_sk_buff_t* odata_skb = pgm_txw_peek (window, tg_sqn + i);
 		const uint16_t odata_tsdu_length = ntohs (odata_skb->pgm_header->pgm_tsdu_length);
@@ -599,6 +611,7 @@
 			is_op_encoded = TRUE;
 		}
 	}
+	}
 
 /* construct basic PGM header to be completed by send_rdata() */
 	skb = window->parity_buffer;
@@ -618,7 +631,9 @@
 	{
 		skb->pgm_header->pgm_options |= PGM_OPT_VAR_PKTLEN;
 
-		for (uint_fast8_t i = 0; i < window->rs.k; i++)
+		{
+		uint_fast8_t i;
+		for (i = 0; i < window->rs.k; i++)
 		{
 			struct pgm_sk_buff_t* odata_skb = pgm_txw_peek (window, tg_sqn + i);
 			const uint16_t odata_tsdu_length = ntohs (odata_skb->pgm_header->pgm_tsdu_length);
@@ -632,6 +647,7 @@
 				odata_skb->zero_padded = 1;
 			}
 		}
+		}
 		parity_length += 2;
 	}
 
@@ -642,6 +658,7 @@
 
 	skb->pgm_data->data_sqn	= htonl ( tg_sqn | rs_h );
 
+	{
 	void* data_bytes = skb->pgm_data + 1;
 
 /* encode every option separately, currently only one applies: opt_fragment
@@ -650,11 +667,14 @@
 	{
 		skb->pgm_header->pgm_options |= PGM_OPT_PRESENT;
 
+		{
 		struct pgm_opt_fragment null_opt_fragment;
-		const pgm_gf8_t* opt_src[ window->rs.k ];
+		const pgm_gf8_t** opt_src = pgm_newa (pgm_gf8_t*, window->rs.k);
 		memset (&null_opt_fragment, 0, sizeof(null_opt_fragment));
 		*(uint8_t*)&null_opt_fragment |= PGM_OP_ENCODED_NULL;
-		for (uint_fast8_t i = 0; i < window->rs.k; i++)
+		{
+		uint_fast8_t i;
+		for (i = 0; i < window->rs.k; i++)
 		{
 			const struct pgm_sk_buff_t* odata_skb = pgm_txw_peek (window, tg_sqn + i);
 
@@ -669,8 +689,10 @@
 				opt_src[i] = (pgm_gf8_t*)&null_opt_fragment;
 			}
 		}
+		}
 
 /* add options to this rdata packet */
+		{
 		const uint16_t opt_total_length = sizeof(struct pgm_opt_length) +
 						 sizeof(struct pgm_opt_header) +
 						 sizeof(struct pgm_opt_fragment);
@@ -678,14 +700,17 @@
 /* add space for PGM options */
 		pgm_skb_put (skb, opt_total_length);
 
+		{
 		struct pgm_opt_length* opt_len		= data_bytes;
 		opt_len->opt_type			= PGM_OPT_LENGTH;
 		opt_len->opt_length			= sizeof(struct pgm_opt_length);
 		opt_len->opt_total_length		= htons ( opt_total_length );
+		{
 		struct pgm_opt_header* opt_header 	= (struct pgm_opt_header*)(opt_len + 1);
 		opt_header->opt_type			= PGM_OPT_FRAGMENT | PGM_OPT_END;
 		opt_header->opt_length			= sizeof(struct pgm_opt_header) + sizeof(struct pgm_opt_fragment);
 		opt_header->opt_reserved 		= PGM_OP_ENCODED;
+		{
 		struct pgm_opt_fragment* opt_fragment	= (struct pgm_opt_fragment*)(opt_header + 1);
 
 /* The cast below is the correct way to handle the problem. 
@@ -700,6 +725,11 @@
 				sizeof(struct pgm_opt_fragment) - sizeof(struct pgm_opt_header));
 
 		data_bytes = opt_fragment + 1;
+		}
+		}
+		}
+		}
+		}
 	}
 
 /* encode payload */
@@ -710,9 +740,16 @@
 			parity_length);
 
 /* calculate partial checksum */
+	{
 	const uint16_t tsdu_length = ntohs (skb->pgm_header->pgm_tsdu_length);
 	state->unfolded_checksum = pgm_csum_partial ((char*)skb->tail - tsdu_length, tsdu_length, 0);
 	return skb;
+	}
+	}
+	}
+	}
+	}
+	}
 }
 
 /* remove head entry from retransmit queue, will fail on assertion if queue is empty.
@@ -733,6 +770,7 @@
 		(const void*)window);
 
 /* tail link is valid without lock */
+	{
 	pgm_list_t* tail_link = pgm_queue_peek_tail_link (&window->retransmit_queue);
 
 /* link must be valid for pop */
@@ -762,6 +800,7 @@
 		pgm_queue_pop_tail_link (&window->retransmit_queue);
 		state->waiting_retransmit = 0;
 	}
+	}
 }
 
 /* eof */
