--- rxw.c	2010-10-12 14:44:19.000000000 +0800
+++ rxw.c89.c	2010-10-12 17:28:23.000000000 +0800
@@ -192,16 +192,12 @@
 		pgm_assert_cmpuint (max_rte, >, 0);
 	}
 
-#ifndef _MSC_VER
-	pgm_debug ("create (tsi:%s max-tpdu:%" PRIu16 " sqns:%" PRIu32  " secs %u max-rte %zd ack-c_p %" PRIu32 ")",
-		pgm_tsi_print (tsi), tpdu_size, sqns, secs, max_rte, ack_c_p);
-#else
 	pgm_debug ("create (tsi:%s max-tpdu:%" PRIu16 " sqns:%" PRIu32  " secs %u max-rte %ld ack-c_p %" PRIu32 ")",
 		pgm_tsi_print (tsi), tpdu_size, sqns, secs, (long)max_rte, ack_c_p);
-#endif
 
 /* calculate receive window parameters */
 	pgm_assert (sqns || (secs && max_rte));
+	{
 	const unsigned alloc_sqns = sqns ? sqns : ( (secs * max_rte) / tpdu_size );
 	window = pgm_malloc0 (sizeof(pgm_rxw_t) + ( alloc_sqns * sizeof(struct pgm_sk_buff_t*) ));
 
@@ -237,6 +233,7 @@
 	pgm_assert (!pgm_rxw_is_full (window));
 
 	return window;
+	}
 }
 
 /* destructor for receive window.  must not be called more than once for same window.
@@ -370,6 +367,7 @@
 			return _pgm_rxw_insert (window, skb);
 		}
 
+		{
 		const struct pgm_sk_buff_t* const first_skb = _pgm_rxw_peek (window, _pgm_rxw_tg_sqn (window, skb->sequence));
 		const pgm_rxw_state_t* const first_state = (pgm_rxw_state_t*)&first_skb->cb;
 
@@ -384,6 +382,7 @@
 
 		pgm_assert (NULL != first_state);
 		status = _pgm_rxw_add_placeholder_range (window, _pgm_rxw_tg_sqn (window, skb->sequence), now, nak_rb_expiry);
+		}
 	}
 	else
 	{
@@ -548,7 +547,9 @@
 	}
 
 /* remove all buffers between commit lead and advertised rxw_trail */
-	for (uint32_t sequence = window->commit_lead;
+	{
+	uint32_t sequence;
+	for (sequence = window->commit_lead;
 	     pgm_uint32_gt (window->rxw_trail, sequence) && pgm_uint32_gte (window->lead, sequence);
 	     sequence++)
 	{
@@ -573,6 +574,7 @@
 			break;
 		}
 	}
+	}
 
 /* post-conditions: only after flush */
 //	pgm_assert (!pgm_rxw_is_full (window));
@@ -651,8 +653,10 @@
 	}
 
 /* add skb to window */
+	{
 	const uint_fast32_t index_	= skb->sequence % pgm_rxw_max_length (window);
 	window->pdata[index_]		= skb;
+	}
 
 	pgm_rxw_state (window, skb, PGM_PKT_STATE_BACK_OFF);
 
@@ -679,6 +683,7 @@
 	pgm_assert (pgm_uint32_gt (sequence, pgm_rxw_lead (window)));
 
 /* check bounds of commit window */
+	{
 	const uint32_t new_commit_sqns = ( 1 + sequence ) - window->trail;
         if ( !_pgm_rxw_commit_is_empty (window) &&
 	     (new_commit_sqns >= pgm_rxw_max_length (window)) )
@@ -710,6 +715,7 @@
 	pgm_assert (!pgm_rxw_is_full (window));
 
 	return PGM_RXW_APPENDED;
+	}
 }
 
 /* update leading edge of receive window.
@@ -786,22 +792,28 @@
 	if (!skb->pgm_opt_fragment)
 		return FALSE;
 
+	{
 	const uint32_t apdu_first_sqn = ntohl (skb->of_apdu_first_sqn);
 
 /* by definition, first fragment indicates APDU is available */
 	if (apdu_first_sqn == skb->sequence)
 		return FALSE;
 
+	{
 	const struct pgm_sk_buff_t* const first_skb = _pgm_rxw_peek (window, apdu_first_sqn);
 /* first fragment out-of-bounds */
 	if (NULL == first_skb)
 		return TRUE;
 
+	{
 	const pgm_rxw_state_t* first_state = (pgm_rxw_state_t*)&first_skb->cb;
 	if (PGM_PKT_STATE_LOST_DATA == first_state->pkt_state)
 		return TRUE;
 
 	return FALSE;
+	}
+	}
+	}
 }
 
 /* return the first missing packet sequence in the specified transmission
@@ -821,7 +833,9 @@
 /* pre-conditions */
 	pgm_assert (NULL != window);
 
-	for (uint32_t i = tg_sqn, j = 0; j < window->tg_size; i++, j++)
+	{
+	uint32_t i, j;
+	for (i = tg_sqn, j = 0; j < window->tg_size; i++, j++)
 	{
 		skb = _pgm_rxw_peek (window, i);
 		pgm_assert (NULL != skb);
@@ -840,6 +854,7 @@
 		default: pgm_assert_not_reached(); break;
 		}
 	}
+	}
 
 	return NULL;
 }
@@ -867,6 +882,7 @@
 	if (skb->pgm_header->pgm_options & PGM_OPT_VAR_PKTLEN)
 		return FALSE;
 
+	{
 	const uint32_t tg_sqn = _pgm_rxw_tg_sqn (window, skb->sequence);
 	if (tg_sqn == skb->sequence)
 		return FALSE;
@@ -879,6 +895,7 @@
 		return FALSE;
 
 	return TRUE;
+	}
 }
 
 static inline
@@ -913,6 +930,7 @@
 	if (!window->is_fec_available)
 		return FALSE;
 
+	{
 	const uint32_t tg_sqn = _pgm_rxw_tg_sqn (window, skb->sequence);
 	if (tg_sqn == skb->sequence)
 		return FALSE;
@@ -925,6 +943,7 @@
 		return FALSE;
 
 	return TRUE;
+	}
 }
 
 /* insert skb into window range, discard if duplicate.  window will have placeholder,
@@ -997,6 +1016,7 @@
 	}
 
 /* statistics */
+	{
 	const uint32_t fill_time = (uint32_t)(new_skb->tstamp - skb->tstamp);
 	PGM_HISTOGRAM_TIMES("Rx.RepairTime", fill_time);
 	PGM_HISTOGRAM_COUNTS("Rx.NakTransmits", state->nak_transmit_count);
@@ -1021,8 +1041,10 @@
 				window->min_nak_transmit_count = state->nak_transmit_count;
 		}
 	}
+	}
 
 /* add packet to bitmap */
+	{
 	const uint_fast32_t pos = window->lead - new_skb->sequence;
 	if (pos < 32) {
 		window->bitmap |= 1 << pos;
@@ -1033,9 +1055,12 @@
  * x_{t-1} = 0
  *   ∴ s_t = (1 - α) × s_{t-1}
  */
+	{
 	const uint_fast32_t s = pgm_fp16pow (pgm_fp16 (1) - window->ack_c_p, pos);
 	if (s > window->data_loss)	window->data_loss = 0;
 	else				window->data_loss -= s;
+	}
+	}
 
 /* replace place holder skb with incoming skb */
 	memcpy (new_skb->cb, skb->cb, sizeof(skb->cb));
@@ -1043,8 +1068,10 @@
 	state->pkt_state = PGM_PKT_STATE_ERROR;
 	_pgm_rxw_unlink (window, skb);
 	pgm_free_skb (skb);
+	{
 	const uint_fast32_t index_ = new_skb->sequence % pgm_rxw_max_length (window);
 	window->pdata[index_] = new_skb;
+	}
 	if (new_skb->pgm_header->pgm_options & PGM_OPT_PARITY)
 		_pgm_rxw_state (window, new_skb, PGM_PKT_STATE_HAVE_PARITY);
 	else
@@ -1080,10 +1107,14 @@
 	memcpy (cb, skb->cb, sizeof(skb->cb));
 	memcpy (skb->cb, missing->cb, sizeof(skb->cb));
 	memcpy (missing->cb, cb, sizeof(skb->cb));
+	{
 	const uint32_t parity_index = skb->sequence % pgm_rxw_max_length (window);
 	window->pdata[parity_index] = skb;
+	}
+	{
 	const uint32_t missing_index = missing->sequence % pgm_rxw_max_length (window);
 	window->pdata[missing_index] = missing;
+	}
 }
 
 /* skb advances the window lead.
@@ -1146,11 +1177,13 @@
 		lost_skb->sequence		= skb->sequence;
 
 /* add lost-placeholder skb to window */
+		{
 		const uint_fast32_t index_	= lost_skb->sequence % pgm_rxw_max_length (window);
 		window->pdata[index_]		= lost_skb;
 
 		_pgm_rxw_state (window, lost_skb, PGM_PKT_STATE_LOST_DATA);
 		return PGM_RXW_BOUNDS;
+		}
 	}
 
 /* add skb to window */
@@ -1185,6 +1218,7 @@
 /* pre-conditions */
 	pgm_assert (NULL != window);
 
+	{
 	const uint32_t tg_sqn_of_commit_lead = _pgm_rxw_tg_sqn (window, window->commit_lead);
 
 	while (!_pgm_rxw_commit_is_empty (window) &&
@@ -1192,6 +1226,7 @@
 	{
 		_pgm_rxw_remove_trail (window);
 	}
+	}
 }
 
 /* flush packets but instead of calling on_data append the contiguous data packets
@@ -1399,7 +1434,7 @@
 	const uint32_t		tg_sqn		/* transmission group sequence */
 	)
 {
-	struct pgm_sk_buff_t	*skb;
+	struct pgm_sk_buff_t*	skb;
 	pgm_rxw_state_t		*state;
 	struct pgm_sk_buff_t   **tg_skbs;
 	pgm_gf8_t	       **tg_data, **tg_opts;
@@ -1420,11 +1455,14 @@
 	skb = _pgm_rxw_peek (window, tg_sqn);
 	pgm_assert (NULL != skb);
 
+	{
 	const bool is_var_pktlen = skb->pgm_header->pgm_options & PGM_OPT_VAR_PKTLEN;
 	const bool is_op_encoded = skb->pgm_header->pgm_options & PGM_OPT_PRESENT;
 	const uint16_t parity_length = ntohs (skb->pgm_header->pgm_tsdu_length);
 
-	for (uint32_t i = tg_sqn, j = 0; i != (tg_sqn + window->rs.k); i++, j++)
+	{
+	uint32_t i, j;
+	for (i = tg_sqn, j = 0; i != (tg_sqn + window->rs.k); i++, j++)
 	{
 		skb = _pgm_rxw_peek (window, i);
 		pgm_assert (NULL != skb);
@@ -1478,6 +1516,7 @@
 		}
 
 	}
+	}
 
 /* reconstruct payload */
 	pgm_rs_decode_parity_appended (&window->rs,
@@ -1493,7 +1532,9 @@
 					       sizeof(struct pgm_opt_fragment));
 
 /* swap parity skbs with reconstructed skbs */
-	for (uint_fast8_t i = 0; i < window->rs.k; i++)
+	{
+	uint_fast8_t i;
+	for (i = 0; i < window->rs.k; i++)
 	{
 		struct pgm_sk_buff_t* repair_skb;
 
@@ -1508,17 +1549,22 @@
 			if (pktlen > parity_length) {
 				pgm_trace (PGM_LOG_ROLE_RX_WINDOW,_("Invalid encoded variable packet length in reconstructed packet, dropping entire transmission group."));
 				pgm_free_skb (repair_skb);
-				for (uint_fast8_t j = i; j < window->rs.k; j++)
+				{
+				uint_fast8_t j;
+				for (j = i; j < window->rs.k; j++)
 				{
 					if (offsets[j] < window->rs.k)
 						continue;
 					pgm_rxw_lost (window, tg_skbs[offsets[j]]->sequence);
 				}
+				}
 				break;
 			}
+			{
 			const uint16_t padding = parity_length - pktlen;
 			repair_skb->len -= padding;
 			repair_skb->tail = (char*)repair_skb->tail - padding;
+			}
 		}
 
 #ifdef PGM_DISABLE_ASSERT
@@ -1527,6 +1573,8 @@
 		pgm_assert_cmpint (_pgm_rxw_insert (window, repair_skb), ==, PGM_RXW_INSERTED);
 #endif
 	}
+	}
+	}
 }
 
 /* check every TPDU in an APDU and verify that the data has arrived
@@ -1567,6 +1615,7 @@
 		return FALSE;
 	}
 
+	{
 	const size_t apdu_size = skb->pgm_opt_fragment ? ntohl (skb->of_apdu_len) : skb->len;
 	const uint32_t  tg_sqn = _pgm_rxw_tg_sqn (window, first_sequence);
 
@@ -1578,7 +1627,9 @@
 		return FALSE;
 	}
 
-	for (uint32_t sequence = first_sequence; skb; sequence++)
+	{
+	uint32_t sequence = first_sequence;
+	for (sequence = first_sequence; skb; sequence++)
 	{
 		pgm_rxw_state_t* state = (pgm_rxw_state_t*)&skb->cb;
 
@@ -1643,11 +1694,13 @@
 			}
 		}
 
-		skb = _pgm_rxw_peek (window, ++sequence);
+		skb = _pgm_rxw_peek (window, sequence + 1);
 	}
 
 /* pending */
 	return FALSE;
+	}
+	}
 }
 
 /* read one APDU consisting of one or more TPDUs.  target array is guaranteed
@@ -1675,6 +1728,7 @@
 	skb = _pgm_rxw_peek (window, window->commit_lead);
 	pgm_assert (NULL != skb);
 
+	{
 	const size_t apdu_len = skb->pgm_opt_fragment ? ntohl (skb->of_apdu_len) : skb->len;
 	pgm_assert_cmpuint (apdu_len, >=, skb->len);
 
@@ -1695,6 +1749,7 @@
 	pgm_assert (!_pgm_rxw_commit_is_empty (window));
 
 	return contiguous_len;
+	}
 }
 
 /* returns transmission group sequence (TG_SQN) from sequence (SQN).
@@ -1710,8 +1765,10 @@
 /* pre-conditions */
 	pgm_assert (NULL != window);
 
+	{
 	const uint32_t tg_sqn_mask = 0xffffffff << window->tg_sqn_shift;
 	return sequence & tg_sqn_mask;
+	}
 }
 
 /* returns packet number (PKT_SQN) from sequence (SQN).
@@ -1727,8 +1784,10 @@
 /* pre-conditions */
 	pgm_assert (NULL != window);
 
+	{
 	const uint32_t tg_sqn_mask = 0xffffffff << window->tg_sqn_shift;
 	return sequence & ~tg_sqn_mask;
+	}
 }
 
 /* returns TRUE when the sequence is the first of a transmission group.
@@ -2104,8 +2163,10 @@
 	skb->sequence		= window->lead;
 	state->timer_expiry	= nak_rdata_expiry;
 
+	{
 	const uint_fast32_t index_	= pgm_rxw_lead (window) % pgm_rxw_max_length (window);
 	window->pdata[index_]		= skb;
+	}
 	_pgm_rxw_state (window, skb, PGM_PKT_STATE_WAIT_DATA);
 
 	return PGM_RXW_APPENDED;
@@ -2147,7 +2208,7 @@
 		"cumulative_losses = %" PRIu32 ", "
 		"bytes_delivered = %" PRIu32 ", "
 		"msgs_delivered = %" PRIu32 ", "
-		"size = %zu, "
+		"size = %lu, "
 		"alloc = %" PRIu32 ", "
 		"pdata = []"
 		"}",
@@ -2190,7 +2251,7 @@
 		window->cumulative_losses,
 		window->bytes_delivered,
 		window->msgs_delivered,
-		window->size,
+		(unsigned long)window->size,
 		window->alloc
 	);
 }
