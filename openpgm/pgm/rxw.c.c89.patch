--- rxw.c	2010-08-04 17:06:11.000000000 +0800
+++ rxw.c89	2010-08-05 11:36:04.000000000 +0800
@@ -198,11 +198,12 @@
 		pgm_assert_cmpuint (max_rte, >, 0);
 	}
 
-	pgm_debug ("create (tsi:%s max-tpdu:%" PRIu16 " sqns:%" PRIu32  " secs %u max-rte %zd ack-c_p %" PRIu32 ")",
+	pgm_debug ("create (tsi:%s max-tpdu:%" PRIu16 " sqns:%" PRIu32  " secs %u max-rte %ld ack-c_p %" PRIu32 ")",
 		pgm_tsi_print (tsi), tpdu_size, sqns, secs, max_rte, ack_c_p);
 
 /* calculate receive window parameters */
 	pgm_assert (sqns || (secs && max_rte));
+	{
 	const unsigned alloc_sqns = sqns ? sqns : ( (secs * max_rte) / tpdu_size );
 	window = pgm_malloc0 (sizeof(pgm_rxw_t) + ( alloc_sqns * sizeof(struct pgm_sk_buff_t*) ));
 
@@ -238,6 +239,7 @@
 	pgm_assert (!pgm_rxw_is_full (window));
 
 	return window;
+	}
 }
 
 /* destructor for receive window.  must not be called more than once for same window.
@@ -308,7 +310,7 @@
 /* pre-conditions */
 	pgm_assert (NULL != window);
 	pgm_assert (NULL != skb);
-	pgm_assert_cmpuint (nak_rb_expiry, >, 0);
+	pgm_assert_cmpuint ((unsigned int)nak_rb_expiry, >, 0);
 	pgm_assert_cmpuint (pgm_rxw_max_length (window), >, 0);
 	pgm_assert (pgm_skb_is_valid (skb));
 	pgm_assert (((const pgm_list_t*)skb)->next == NULL);
@@ -371,6 +373,7 @@
 			return _pgm_rxw_insert (window, skb);
 		}
 
+		{
 		const struct pgm_sk_buff_t* const first_skb = _pgm_rxw_peek (window, _pgm_rxw_tg_sqn (window, skb->sequence));
 		const pgm_rxw_state_t* const first_state = (pgm_rxw_state_t*)&first_skb->cb;
 
@@ -385,6 +388,7 @@
 
 		pgm_assert (NULL != first_state);
 		status = _pgm_rxw_add_placeholder_range (window, _pgm_rxw_tg_sqn (window, skb->sequence), now, nak_rb_expiry);
+		}
 	}
 	else
 	{
@@ -468,7 +472,7 @@
 {
 /* pre-conditions */
 	pgm_assert (NULL != window);
-	pgm_assert_cmpuint (nak_rb_expiry, >, 0);
+	pgm_assert_cmpuint ((unsigned int)nak_rb_expiry, >, 0);
 
 	pgm_debug ("pgm_rxw_update (window:%p txw-lead:%" PRIu32 " txw-trail:%" PRIu32 " nak-rb-expiry:%" PGM_TIME_FORMAT ")",
 		(void*)window, txw_lead, txw_trail, nak_rb_expiry);
@@ -549,7 +553,9 @@
 	}
 
 /* remove all buffers between commit lead and advertised rxw_trail */
-	for (uint32_t sequence = window->commit_lead;
+	{
+	uint32_t sequence;
+	for (sequence = window->commit_lead;
 	     pgm_uint32_gt (window->rxw_trail, sequence) && pgm_uint32_gte (window->lead, sequence);
 	     sequence++)
 	{
@@ -574,6 +580,7 @@
 			break;
 		}
 	}
+	}
 
 /* post-conditions: only after flush */
 //	pgm_assert (!pgm_rxw_is_full (window));
@@ -636,6 +643,7 @@
 	window->data_loss = window->ack_c_p + pgm_fp16mul ((pgm_fp16 (1) - window->ack_c_p), window->data_loss);
 
 	skb			= pgm_alloc_skb (window->max_tpdu);
+	{
 	pgm_rxw_state_t* state	= (pgm_rxw_state_t*)&skb->cb;
 	skb->tstamp		= now;
 	skb->sequence		= window->lead;
@@ -651,6 +659,7 @@
 	}
 
 /* add skb to window */
+	{
 	const uint_fast32_t index_	= skb->sequence % pgm_rxw_max_length (window);
 	window->pdata[index_]		= skb;
 
@@ -660,6 +669,8 @@
 	pgm_assert_cmpuint (pgm_rxw_length (window), >, 0);
 	pgm_assert_cmpuint (pgm_rxw_length (window), <=, pgm_rxw_max_length (window));
 	pgm_assert_cmpuint (_pgm_rxw_incoming_length (window), >, 0);
+	}
+	}
 }
 
 /* add a range of placeholders to the window.
@@ -679,6 +690,7 @@
 	pgm_assert (pgm_uint32_gt (sequence, pgm_rxw_lead (window)));
 
 /* check bounds of commit window */
+	{
 	const uint32_t new_commit_sqns = ( 1 + sequence ) - window->trail;
         if ( !_pgm_rxw_commit_is_empty (window) &&
 	     (new_commit_sqns >= pgm_rxw_max_length (window)) )
@@ -710,6 +722,7 @@
 	pgm_assert (!pgm_rxw_is_full (window));
 
 	return PGM_RXW_APPENDED;
+	}
 }
 
 /* update leading edge of receive window.
@@ -733,6 +746,7 @@
 	if (PGM_UNLIKELY(pgm_uint32_lte (txw_lead, window->lead)))
 		return 0;
 
+	{
 	uint32_t lead;
 
 /* committed packets limit constrain the lead until they are released */
@@ -746,6 +760,7 @@
 	else
 		lead = txw_lead;
 
+	{
 	unsigned lost = 0;
 
 	while (window->lead != lead)
@@ -761,6 +776,8 @@
 	}
 
 	return lost;
+	}
+	}
 }
 
 /* checks whether an APDU is unrecoverable due to lost TPDUs.
@@ -786,22 +803,28 @@
 	if (!skb->pgm_opt_fragment)
 		return FALSE;
 
+	{
 	const uint32_t apdu_first_sqn = ntohl (skb->of_apdu_first_sqn);
 
 /* by definition, first fragment indicates APDU is available */
 	if (apdu_first_sqn == skb->sequence)
 		return FALSE;
 
+	{
 	const struct pgm_sk_buff_t* const first_skb = _pgm_rxw_peek (window, apdu_first_sqn);
 /* first fragment out-of-bounds */
 	if (NULL == first_skb)
 		return TRUE;
 
+	{
 	const pgm_rxw_state_t* first_state = (pgm_rxw_state_t*)&first_skb->cb;
 	if (PGM_PKT_STATE_LOST_DATA == first_state->pkt_state)
 		return TRUE;
 
 	return FALSE;
+	}
+	}
+	}
 }
 
 /* return the first missing packet sequence in the specified transmission
@@ -821,7 +844,9 @@
 /* pre-conditions */
 	pgm_assert (NULL != window);
 
-	for (uint32_t i = tg_sqn, j = 0; j < window->tg_size; i++, j++)
+	{
+	uint32_t i, j;
+	for (i = tg_sqn, j = 0; j < window->tg_size; i++, j++)
 	{
 		skb = _pgm_rxw_peek (window, i);
 		pgm_assert (NULL != skb);
@@ -840,6 +865,7 @@
 		default: pgm_assert_not_reached(); break;
 		}
 	}
+	}
 
 	return NULL;
 }
@@ -867,6 +893,7 @@
 	if (skb->pgm_header->pgm_options & PGM_OPT_VAR_PKTLEN)
 		return FALSE;
 
+	{
 	const uint32_t tg_sqn = _pgm_rxw_tg_sqn (window, skb->sequence);
 	if (tg_sqn == skb->sequence)
 		return FALSE;
@@ -879,6 +906,7 @@
 		return FALSE;
 
 	return TRUE;
+	}
 }
 
 static inline
@@ -913,6 +941,7 @@
 	if (!window->is_fec_available)
 		return FALSE;
 
+	{
 	const uint32_t tg_sqn = _pgm_rxw_tg_sqn (window, skb->sequence);
 	if (tg_sqn == skb->sequence)
 		return FALSE;
@@ -925,6 +954,7 @@
 		return FALSE;
 
 	return TRUE;
+	}
 }
 
 /* insert skb into window range, discard if duplicate.  window will have placeholder,
@@ -997,20 +1027,21 @@
 	}
 
 /* statistics */
+	{
 	const pgm_time_t fill_time = new_skb->tstamp - skb->tstamp;
 	PGM_HISTOGRAM_TIMES("Rx.RepairTime", fill_time);
 	PGM_HISTOGRAM_COUNTS("Rx.NakTransmits", state->nak_transmit_count);
 	PGM_HISTOGRAM_COUNTS("Rx.NcfRetries", state->ncf_retry_count);
 	PGM_HISTOGRAM_COUNTS("Rx.DataRetries", state->data_retry_count);
 	if (!window->max_fill_time) {
-		window->max_fill_time = window->min_fill_time = fill_time;
+		window->max_fill_time = window->min_fill_time = (uint32_t)fill_time;
 	}
 	else
 	{
 		if (fill_time > window->max_fill_time)
-			window->max_fill_time = fill_time;
+			window->max_fill_time = (uint32_t)fill_time;
 		else if (fill_time < window->min_fill_time)
-			window->min_fill_time = fill_time;
+			window->min_fill_time = (uint32_t)fill_time;
 
 		if (!window->max_nak_transmit_count) {
 			window->max_nak_transmit_count = window->min_nak_transmit_count = state->nak_transmit_count;
@@ -1023,6 +1054,7 @@
 	}
 
 /* add packet to bitmap */
+	{
 	const uint_fast32_t pos = window->lead - new_skb->sequence;
 	if (pos < 32) {
 		window->bitmap |= 1 << pos;
@@ -1033,16 +1065,19 @@
  * x_{t-1} = 0
  *   ∴ s_t = (1 - α) × s_{t-1}
  */
+	{
 	const uint_fast32_t s = pgm_fp16pow (pgm_fp16 (1) - window->ack_c_p, pos);
 	if (s > window->data_loss)	window->data_loss = 0;
 	else				window->data_loss -= s;
 
 /* replace place holder skb with incoming skb */
 	memcpy (new_skb->cb, skb->cb, sizeof(skb->cb));
+	{
 	pgm_rxw_state_t* rxw_state = (void*)new_skb->cb;
 	rxw_state->pkt_state = PGM_PKT_STATE_ERROR;
 	_pgm_rxw_unlink (window, skb);
 	pgm_free_skb (skb);
+	{
 	const uint_fast32_t index_ = new_skb->sequence % pgm_rxw_max_length (window);
 	window->pdata[index_] = new_skb;
 	if (new_skb->pgm_header->pgm_options & PGM_OPT_PARITY)
@@ -1052,6 +1087,11 @@
 	window->size += new_skb->len;
 
 	return PGM_RXW_INSERTED;
+	}
+	}
+	}
+	}
+	}
 }
 
 /* shuffle parity packet at skb->sequence to any other needed spot.
@@ -1070,11 +1110,13 @@
 	pgm_assert (NULL != window);
 	pgm_assert (NULL != skb);
 
+	{
 	struct pgm_sk_buff_t* restrict missing = _pgm_rxw_find_missing (window, skb->sequence);
 	if (NULL == missing)
 		return;
 
 /* replace place holder skb with parity skb */
+	{
 	char cb[48];
 	_pgm_rxw_unlink (window, missing);
 	memcpy (cb, skb->cb, sizeof(skb->cb));
@@ -1084,6 +1126,8 @@
 	window->pdata[index_] = skb;
 	index_ = missing->sequence % pgm_rxw_max_length (window);
 	window->pdata[index_] = missing;
+	}
+	}
 }
 
 /* skb advances the window lead.
@@ -1146,11 +1190,13 @@
 		lost_skb->sequence		= skb->sequence;
 
 /* add lost-placeholder skb to window */
+		{
 		const uint_fast32_t index_	= lost_skb->sequence % pgm_rxw_max_length (window);
 		window->pdata[index_]		= lost_skb;
 
 		_pgm_rxw_state (window, lost_skb, PGM_PKT_STATE_LOST_DATA);
 		return PGM_RXW_BOUNDS;
+		}
 	}
 
 /* add skb to window */
@@ -1185,6 +1231,7 @@
 /* pre-conditions */
 	pgm_assert (NULL != window);
 
+	{
 	const uint32_t tg_sqn_of_commit_lead = _pgm_rxw_tg_sqn (window, window->commit_lead);
 
 	while (!_pgm_rxw_commit_is_empty (window) &&
@@ -1192,6 +1239,7 @@
 	{
 		_pgm_rxw_remove_trail (window);
 	}
+	}
 }
 
 /* flush packets but instead of calling on_data append the contiguous data packets
@@ -1344,7 +1392,9 @@
 	pgm_debug ("_pgm_rxw_incoming_read (window:%p pmsg:%p pmsglen:%u)",
 		 (void*)window, (void*)pmsg, pmsglen);
 
+	{
 	msg_end = *pmsg + pmsglen - 1;
+	{
 	ssize_t bytes_read = 0;
 	size_t data_read = 0;
 
@@ -1363,6 +1413,8 @@
 	window->bytes_delivered += bytes_read;
 	window->msgs_delivered  += data_read;
 	return data_read > 0 ? bytes_read : -1;
+	}
+	}
 }
 
 /* returns TRUE if transmission group is lost.
@@ -1411,16 +1463,19 @@
 	skb = _pgm_rxw_peek (window, tg_sqn);
 	pgm_assert (NULL != skb);
 
+	{
 	const bool is_var_pktlen = skb->pgm_header->pgm_options & PGM_OPT_VAR_PKTLEN;
 	const bool is_op_encoded = skb->pgm_header->pgm_options & PGM_OPT_PRESENT;
 	const uint16_t parity_length = ntohs (skb->pgm_header->pgm_tsdu_length);
-	struct pgm_sk_buff_t* tg_skbs[ window->rs.n ];
-	pgm_gf8_t* tg_data[ window->rs.n ];
-	pgm_gf8_t* tg_opts[ window->rs.n ];
-	uint8_t offsets[ window->rs.k ];
+	struct pgm_sk_buff_t** tg_skbs = pgm_newa (struct pgm_sk_buff_t*, window->rs.n);
+	pgm_gf8_t** tg_data = pgm_newa (pgm_gf8_t*, window->rs.n);
+	pgm_gf8_t** tg_opts = pgm_newa (pgm_gf8_t*, window->rs.n);
+	uint8_t* offsets = pgm_newa (uint8_t, window->rs.k);
 	uint8_t rs_h = 0;
 
-	for (uint32_t i = tg_sqn, j = 0; i != (tg_sqn + window->rs.k); i++, j++)
+	{
+	uint32_t i, j;
+	for (i = tg_sqn, j = 0; i != (tg_sqn + window->rs.k); i++, j++)
 	{
 		skb = _pgm_rxw_peek (window, i);
 		pgm_assert (NULL != skb);
@@ -1474,6 +1529,7 @@
 		}
 
 	}
+	}
 
 /* reconstruct payload */
 	pgm_rs_decode_parity_appended (&window->rs,
@@ -1489,11 +1545,14 @@
 					       sizeof(struct pgm_opt_fragment));
 
 /* swap parity skbs with reconstructed skbs */
-	for (uint_fast8_t i = 0; i < window->rs.k; i++)
+	{
+	uint_fast8_t i;
+	for (i = 0; i < window->rs.k; i++)
 	{
 		if (offsets[i] < window->rs.k)
 			continue;
 
+		{
 		struct pgm_sk_buff_t* repair_skb = tg_skbs[i];
 
 		if (is_var_pktlen)
@@ -1502,17 +1561,22 @@
 			if (pktlen > parity_length) {
 				pgm_trace (PGM_LOG_ROLE_RX_WINDOW,_("Invalid encoded variable packet length in reconstructed packet, dropping entire transmission group."));
 				pgm_free_skb (repair_skb);
-				for (uint_fast8_t j = i; j < window->rs.k; j++)
+				{
+				uint_fast8_t j;
+				for (j = i; j < window->rs.k; j++)
 				{
 					if (offsets[j] < window->rs.k)
 						continue;
 					pgm_rxw_lost (window, tg_skbs[offsets[j]]->sequence);
 				}
+				}
 				break;
 			}
+			{
 			const uint16_t padding = parity_length - pktlen;
 			repair_skb->len -= padding;
 			repair_skb->tail = (char*)repair_skb->tail - padding;
+			}
 		}
 
 #ifdef PGM_DISABLE_ASSERT
@@ -1520,6 +1584,9 @@
 #else
 		pgm_assert_cmpint (_pgm_rxw_insert (window, repair_skb), ==, PGM_RXW_INSERTED);
 #endif
+		}
+	}
+	}
 	}
 }
 
@@ -1559,6 +1626,7 @@
 		return FALSE;
 	}
 
+	{
 	const size_t apdu_size = skb->pgm_opt_fragment ? ntohl (skb->of_apdu_len) : skb->len;
 	const uint32_t tg_sqn = _pgm_rxw_tg_sqn (window, first_sequence);
 	uint32_t sequence = first_sequence;
@@ -1643,6 +1711,7 @@
 
 /* pending */
 	return FALSE;
+	}
 }
 
 /* read one APDU consisting of one or more TPDUs.  target array is guaranteed
@@ -1666,6 +1735,7 @@
 		(const void*)window, (const void*)pmsg);
 
 	skb = _pgm_rxw_peek (window, window->commit_lead);
+	{
 	size_t contiguous_len = 0;
 	const size_t apdu_len = skb->pgm_opt_fragment ? ntohl (skb->of_apdu_len) : skb->len;
 	unsigned i = 0;
@@ -1687,7 +1757,8 @@
 /* post-conditions */
 	pgm_assert (!_pgm_rxw_commit_is_empty (window));
 
-return contiguous_len;
+	return contiguous_len;
+	}
 }
 
 /* returns transmission group sequence (TG_SQN) from sequence (SQN).
@@ -1703,8 +1774,10 @@
 /* pre-conditions */
 	pgm_assert (NULL != window);
 
+	{
 	const uint32_t tg_sqn_mask = 0xffffffff << window->tg_sqn_shift;
 	return sequence & tg_sqn_mask;
+	}
 }
 
 /* returns packet number (PKT_SQN) from sequence (SQN).
@@ -1720,8 +1793,10 @@
 /* pre-conditions */
 	pgm_assert (NULL != window);
 
+	{
 	const uint32_t tg_sqn_mask = 0xffffffff << window->tg_sqn_shift;
 	return sequence & ~tg_sqn_mask;
+	}
 }
 
 /* returns TRUE when the sequence is the first of a transmission group.
@@ -1849,6 +1924,7 @@
 	pgm_assert (NULL != window);
 	pgm_assert (NULL != skb);
 
+	{
 	pgm_rxw_state_t* state = (pgm_rxw_state_t*)&skb->cb;
 
 	switch (state->pkt_state) {
@@ -1898,6 +1974,7 @@
 	state->pkt_state = PGM_PKT_STATE_ERROR;
 	pgm_assert (((pgm_list_t*)skb)->next == NULL);
 	pgm_assert (((pgm_list_t*)skb)->prev == NULL);
+	}
 }
 
 /* returns the pointer at the given index of the window.
@@ -2017,8 +2094,10 @@
 	pgm_assert (NULL != window);
 
 /* fetch skb from window and bump expiration times */
+	{
 	struct pgm_sk_buff_t* skb = _pgm_rxw_peek (window, sequence);
 	pgm_assert (NULL != skb);
+	{
 	pgm_rxw_state_t* state = (pgm_rxw_state_t*)&skb->cb;
 	switch (state->pkt_state) {
 	case PGM_PKT_STATE_BACK_OFF:
@@ -2040,6 +2119,8 @@
 	}
 
 	return PGM_RXW_DUPLICATE;
+	}
+	}
 }
 
 /* append an skb to the incoming window with WAIT-DATA state.
@@ -2085,16 +2166,20 @@
 	window->data_loss = window->ack_c_p + pgm_fp16mul (pgm_fp16 (1) - window->ack_c_p, window->data_loss);
 
 	skb			= pgm_alloc_skb (window->max_tpdu);
+	{
 	pgm_rxw_state_t* state	= (pgm_rxw_state_t*)&skb->cb;
 	skb->tstamp		= now;
 	skb->sequence		= window->lead;
 	state->timer_expiry	= nak_rdata_expiry;
 
+	{
 	const uint_fast32_t index_	= pgm_rxw_lead (window) % pgm_rxw_max_length (window);
 	window->pdata[index_]		= skb;
 	_pgm_rxw_state (window, skb, PGM_PKT_STATE_WAIT_DATA);
 
 	return PGM_RXW_APPENDED;
+	}
+	}
 }
 
 /* dumps window state to stdout
@@ -2133,7 +2218,7 @@
 		"cumulative_losses = %" PRIu32 ", "
 		"bytes_delivered = %" PRIu32 ", "
 		"msgs_delivered = %" PRIu32 ", "
-		"size = %zu, "
+		"size = %lu, "
 		"alloc = %" PRIu32 ", "
 		"pdata = []"
 		"}",
