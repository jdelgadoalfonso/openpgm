--- time.c	2010-08-04 18:15:50.000000000 +0800
+++ time.c89	2010-08-05 12:22:53.000000000 +0800
@@ -232,7 +232,15 @@
 		return TRUE;
 
 /* current time */
+#ifdef _MSC_VER
+	{
+        char* cfg = NULL;
+        size_t len;
+        errno_t err = _dupenv_s (&cfg, &len, "PGM_TIMER");
+#else
+	{
 	const char *cfg = getenv ("PGM_TIMER");
+#endif
 	if (cfg == NULL) {
 #ifdef CONFIG_HAVE_TSC
 		cfg = "TSC";
@@ -292,6 +300,13 @@
 #endif
 	}
 
+#ifdef _MSC_VER
+/* cleanup after _dupenv_s() */
+	if (!err && len > 0) {
+		free (cfg);
+	}
+#endif
+
 #ifdef CONFIG_HAVE_RTC
 	if (pgm_time_update_now == pgm_rtc_update)
 	{
@@ -324,10 +339,12 @@
 			fclose (fp);
 		}
 #elif defined(_WIN32)
+		{
 		uint64_t frequency;
 		if (QueryPerformanceFrequency ((LARGE_INTEGER*)&frequency))
 		{
-			tsc_mhz = frequency / 1000;
+			tsc_mhz = (uint_fast32_t)(frequency / 1000);
+		}
 		}
 #endif /* !_WIN32 */
 
@@ -335,10 +352,20 @@
  *
  * Value can be used to override kernel tick rate as well as internal calibration
  */
+		{
+#ifdef _MSC_VER
+	        char* env_mhz = NULL;
+        	size_t len;
+        	errno_t err = _dupenv_s (&env_mhz, &len, "RDTSC_FREQUENCY");
+#else
 		const char *env_mhz = getenv ("RDTSC_FREQUENCY");
+#endif
 		if (env_mhz)
 			tsc_mhz = atoi (env_mhz);
-
+#ifdef _MSC_VER
+			free (env_mhz);
+#endif
+		}
 #ifndef _WIN32
 /* calibrate */
 		if (0 >= tsc_mhz) {
@@ -394,6 +421,7 @@
 err_cleanup:
 	pgm_atomic_dec32 (&time_ref_count);
 	return FALSE;
+	}
 }
 
 /* returns TRUE if shutdown succeeded, returns FALSE on error.
@@ -407,6 +435,7 @@
 	if (pgm_atomic_exchange_and_add32 (&time_ref_count, (uint32_t)-1) != 1)
 		return TRUE;
 
+	{
 	bool success = TRUE;
 #ifdef CONFIG_HAVE_RTC
 	if (pgm_time_update_now == pgm_rtc_update)
@@ -417,6 +446,7 @@
 		success = pgm_hpet_shutdown ();
 #endif
 	return success;
+	}
 }
 
 #ifdef CONFIG_HAVE_GETTIMEOFDAY
@@ -456,14 +486,21 @@
 pgm_time_t
 pgm_ftime_update (void)
 {
-	struct timeb ftime_now;
 	static pgm_time_t last = 0;
+#ifdef _MSC_VER
+	struct __timeb64 ftime_now;
+	_ftime64_s (&ftime_now);
+#else
+	struct timeb ftime_now;
 	ftime (&ftime_now);
+#endif
+	{
 	const pgm_time_t now = secs_to_usecs (ftime_now.time) + msecs_to_usecs (ftime_now.millitm);
 	if (PGM_UNLIKELY(now < last))
 		return last;
 	else
 		return last = now;
+	}
 }
 #endif /* CONFIG_HAVE_FTIME */
 
