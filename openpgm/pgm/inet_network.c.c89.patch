--- inet_network.c	2010-05-21 11:32:20.000000000 +0800
+++ inet_network.c89	2010-10-06 17:30:52.000000000 +0800
@@ -70,6 +70,7 @@
 	pgm_debug ("pgm_inet_network (s:\"%s\" in:%p)",
 		 s, (const void*)in);
 
+	{
 	const char *p = s;
 	unsigned val = 0;
 	int shift = 24;
@@ -121,13 +122,16 @@
 //g_trace ("bit mask %i", val);
 
 /* zero out host bits */
-			const struct in_addr netaddr = { .s_addr = cidr_to_netmask (val) };
+			{
+			struct in_addr netaddr;
+			netaddr.s_addr = cidr_to_netmask (val);
 #ifdef INET_NETWORK_DEBUG
 {
 g_debug ("netaddr %s", inet_ntoa (netaddr));
 }
 #endif
 			in->s_addr &= netaddr.s_addr;
+			}
 			return 0;
 		
 		} else if (*p == 'x' || *p == 'X') {	/* skip number, e.g. 1.x.x.x */
@@ -145,6 +149,7 @@
 
 	in->s_addr |= val << shift;
 	return 0;
+	}
 }
 
 /* Converts a numbers-and-dots notation string into an IPv6 network number.
@@ -174,6 +179,7 @@
  * as we are dealing with network addresses IPv6 zone indices are not important
  * so we can use the inet_xtoy functions.
  */
+	{
 	char s2[INET6_ADDRSTRLEN];
 	const char *p = s;
 	char* p2 = s2;
@@ -202,6 +208,7 @@
 #endif
 
 	p++;
+	{
 	unsigned val = 0;
 	while (*p)
 	{
@@ -222,15 +229,22 @@
 	pgm_debug ("subnet size %i", val);
 
 /* zero out host bits */
+	{
 	const unsigned suffix_length = 128 - val;
-	for (int i = suffix_length, j = 15; i > 0; i -= 8, --j)
+	{
+	int i, j;
+	for (i = suffix_length, j = 15; i > 0; i -= 8, --j)
 	{
 		in6->s6_addr[ j ] &= i >= 8 ? 0x00 : (unsigned)(( 0xffU << i ) & 0xffU );
 	}
+	}
 
 	pgm_debug ("effective IPv6 network address after subnet mask: %s", pgm_inet_ntop(AF_INET6, in6, s2, sizeof(s2)));
 
 	return 0;
+	}
+	}
+	}
 }
 
 /* eof */
