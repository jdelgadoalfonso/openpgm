--- net.c	2010-11-18 03:52:18.000000000 +0800
+++ net.c89.c	2010-11-11 03:50:53.000000000 +0800
@@ -36,6 +36,7 @@
 
 #define NET_DEBUG
 
+
 ssize_t
 pgm_skb_sendto_hops (
 	pgm_sock_t*	       restrict sock,
@@ -63,6 +64,7 @@
 //		pgm_sockaddr_multicast_hops (send_sock, sock->send_gsr.gsr_group.ss_family, hops);
 
 /* stack-based WSABUF */
+	{
 	WSABUF DataBuf;
 	DataBuf.len = len;
 	DataBuf.buf = (char*)skb->head;
@@ -70,6 +72,7 @@
 	pgm_skb_get (skb);
 	skb->IOOperation = IO_OPERATION_SEND;
 
+	{
 	int rc = WSASendTo (send_sock, &DataBuf, 1, NULL, 0, to, (socklen_t)tolen, (LPWSAOVERLAPPED)&skb->Overlapped, NULL);
 	if (SOCKET_ERROR == rc && WSA_IO_PENDING != WSAGetLastError()) {
 		int save_errno = pgm_get_last_sock_error();
@@ -78,6 +81,8 @@
 			  pgm_sock_strerror_s (errbuf, sizeof (errbuf), save_errno));
 		pgm_free_skb (skb);
 	}
+	}
+	}
 
 /* revert to default value hop limit */
 //	if (-1 != hops)
@@ -86,7 +91,7 @@
 //		pgm_mutex_unlock (&sock->send_mutex);
 	return 0;
 }
-	
+
 /* locked and rate regulated sendto
  *
  * on success, returns number of bytes sent.  on error, -1 is returned, and
@@ -112,6 +117,7 @@
 	pgm_assert( tolen > 0 );
 
 #ifdef NET_DEBUG
+	{
 	char saddr[INET_ADDRSTRLEN];
 	pgm_sockaddr_ntop (to, saddr, sizeof(saddr));
 	pgm_debug ("pgm_sendto (sock:%p use_rate_limit:%s use_router_alert:%s buf:%p len:%" PRIzu " to:%s [toport:%d] tolen:%d)",
@@ -119,12 +125,14 @@
 		use_rate_limit ? "TRUE" : "FALSE",
 		use_router_alert ? "TRUE" : "FALSE",
 		(const void*)buf,
-		len,
+		(unsigned long)len,
 		saddr,
 		ntohs (((const struct sockaddr_in*)to)->sin_port),
 		(int)tolen);
+	}
 #endif
 
+	{
 	const SOCKET send_sock = use_router_alert ? sock->send_with_router_alert_sock : sock->send_sock;
 
 	if (use_rate_limit && 
@@ -139,15 +147,17 @@
 	if (-1 != hops)
 		pgm_sockaddr_multicast_hops (send_sock, sock->send_gsr.gsr_group.ss_family, hops);
 
-	ssize_t sent = sendto (send_sock, buf, len, 0, to, (socklen_t)tolen);
-	pgm_debug ("sendto returned %" PRIzd, sent);
-	if (sent < 0) {
+	{
+	ssize_t sent = sendto (send_sock, buf, (int)len, 0, to, (socklen_t)tolen);
+	pgm_debug ("sendto returned %" PRIzd, (long)sent);
+	if (sent < 0)
+	{
 		int save_errno = pgm_get_last_sock_error();
-		char errbuf[1024];
 		if (PGM_UNLIKELY(save_errno != PGM_SOCK_ENETUNREACH &&	/* Network is unreachable */
 		 		 save_errno != PGM_SOCK_EHOSTUNREACH &&	/* No route to host */
 		    		 save_errno != PGM_SOCK_EAGAIN))	/* would block on non-blocking send */
 		{
+			char errbuf[1024];
 #ifdef CONFIG_HAVE_POLL
 /* poll for cleared socket */
 			struct pollfd p = {
@@ -158,18 +168,23 @@
 			const int ready = poll (&p, 1, 500 /* ms */);
 #else
 			fd_set writefds;
+			struct timeval tv;
+			int ready;
+#	ifndef _WIN32
+			int n_fds = send_sock + 1;	/* largest fd + 1 */
+#	else
+			int n_fds = 1;			/* count of fds */
+#	endif
 			FD_ZERO(&writefds);
 			FD_SET(send_sock, &writefds);
-			struct timeval tv = {
-				.tv_sec  = 0,
-				.tv_usec = 500 /* ms */ * 1000
-			};
-			const int ready = select (1, NULL, &writefds, NULL, &tv);
+			tv.tv_sec  = 0;
+			tv.tv_usec = 500 /* ms */ * 1000;
+			ready = select (n_fds, NULL, &writefds, NULL, &tv);
 #endif /* CONFIG_HAVE_POLL */
 			if (ready > 0)
 			{
-				sent = sendto (send_sock, buf, len, 0, to, (socklen_t)tolen);
-				if ( sent < 0 )
+				sent = sendto (send_sock, buf, (int)len, 0, to, (socklen_t)tolen);
+				if (sent < 0)
 				{
 					char toaddr[INET6_ADDRSTRLEN];
 					save_errno = pgm_get_last_sock_error();
@@ -199,7 +214,9 @@
 		pgm_sockaddr_multicast_hops (send_sock, sock->send_gsr.gsr_group.ss_family, sock->hops);
 	if (!use_router_alert && sock->can_send_data)
 		pgm_mutex_unlock (&sock->send_mutex);
-	return sent;
+	return (ssize_t)sent;
+	}
+	}
 }
 
 /* socket helper, for setting pipe ends non-blocking
