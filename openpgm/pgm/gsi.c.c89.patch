--- gsi.c	2011-07-29 12:11:51.000000000 +0800
+++ gsi.c89.c	2011-08-01 14:08:03.000000000 +0800
@@ -19,9 +19,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-#ifdef HAVE_CONFIG_H
-#	include <config.h>
-#endif
+#include <config.h>
 #include <errno.h>
 #include <stdio.h>
 #ifndef _WIN32
@@ -50,12 +48,14 @@
 	pgm_return_val_if_fail (NULL != data, FALSE);
 	pgm_return_val_if_fail (length > 1, FALSE);
 
+	{
 	struct pgm_md5_t ctx;
 	char resblock[16];
 	pgm_md5_init_ctx (&ctx);
 	pgm_md5_process_bytes (&ctx, data, length);
 	pgm_md5_finish_ctx (&ctx, resblock);
 	memcpy (gsi, resblock + 10, 6);
+	}
 	return TRUE;
 }
 
@@ -89,6 +89,7 @@
 {
 	pgm_return_val_if_fail (NULL != gsi, FALSE);
 
+	{
 	char hostname[NI_MAXHOST];
 	int retval = gethostname (hostname, sizeof(hostname));
 	if (0 != retval) {
@@ -104,6 +105,7 @@
 	}
 
 	return pgm_gsi_create_from_string (gsi, hostname, -1);
+	}
 }
 
 /* create a global session ID based on the IP address.
@@ -122,6 +124,7 @@
 
 	pgm_return_val_if_fail (NULL != gsi, FALSE);
 
+	{
 	int retval = gethostname (hostname, sizeof(hostname));
 	if (0 != retval) {
 		const int save_errno = pgm_get_last_sock_error();
@@ -152,8 +155,11 @@
  */
 	memcpy (gsi, &((struct sockaddr_in*)(res->ai_addr))->sin_addr, sizeof(struct in_addr));
 	freeaddrinfo (res);
+	{
 	const uint16_t random_val = pgm_random_int_range (0, UINT16_MAX);
 	memcpy ((uint8_t*)gsi + sizeof(struct in_addr), &random_val, sizeof(random_val));
+	}
+	}
 	return TRUE;
 }
 
