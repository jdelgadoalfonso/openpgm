--- gsi.c	2011-06-25 22:34:16.000000000 +0800
+++ gsi.c89.c	2011-06-26 07:58:12.000000000 +0800
@@ -48,12 +48,14 @@
 	pgm_return_val_if_fail (NULL != data, FALSE);
 	pgm_return_val_if_fail (length > 1, FALSE);
 
+	{
 	struct pgm_md5_t ctx;
 	char resblock[16];
 	pgm_md5_init_ctx (&ctx);
 	pgm_md5_process_bytes (&ctx, data, length);
 	pgm_md5_finish_ctx (&ctx, resblock);
 	memcpy (gsi, resblock + 10, 6);
+	}
 	return TRUE;
 }
 
@@ -87,6 +89,7 @@
 {
 	pgm_return_val_if_fail (NULL != gsi, FALSE);
 
+	{
 	char hostname[NI_MAXHOST];
 	int retval = gethostname (hostname, sizeof(hostname));
 	if (0 != retval) {
@@ -102,6 +105,7 @@
 	}
 
 	return pgm_gsi_create_from_string (gsi, hostname, -1);
+	}
 }
 
 /* create a global session ID based on the IP address.
@@ -120,6 +124,7 @@
 
 	pgm_return_val_if_fail (NULL != gsi, FALSE);
 
+	{
 	int retval = gethostname (hostname, sizeof(hostname));
 	if (0 != retval) {
 		const int save_errno = pgm_get_last_sock_error();
@@ -150,8 +155,11 @@
  */
 	memcpy (gsi, &((struct sockaddr_in*)(res->ai_addr))->sin_addr, sizeof(struct in_addr));
 	freeaddrinfo (res);
+	{
 	const uint16_t random_val = pgm_random_int_range (0, UINT16_MAX);
 	memcpy ((uint8_t*)gsi + sizeof(struct in_addr), &random_val, sizeof(random_val));
+	}
+	}
 	return TRUE;
 }
 
