--- gsi.c	2011-06-19 07:26:54.000000000 +0800
+++ gsi.c89.c	2011-06-19 07:27:20.000000000 +0800
@@ -55,12 +55,14 @@
 	memcpy (gsi, g_checksum_get_string (checksum) + 10, 6);
 	g_checksum_free (checksum);
 #else
+	{
 	struct pgm_md5_t ctx;
 	char resblock[16];
 	pgm_md5_init_ctx (&ctx);
 	pgm_md5_process_bytes (&ctx, data, length);
 	pgm_md5_finish_ctx (&ctx, resblock);
 	memcpy (gsi, resblock + 10, 6);
+	}
 #endif
 	return TRUE;
 }
@@ -95,6 +97,7 @@
 {
 	pgm_return_val_if_fail (NULL != gsi, FALSE);
 
+	{
 	char hostname[NI_MAXHOST];
 	int retval = gethostname (hostname, sizeof(hostname));
 	if (0 != retval) {
@@ -110,6 +113,7 @@
 	}
 
 	return pgm_gsi_create_from_string (gsi, hostname, -1);
+	}
 }
 
 /* create a global session ID based on the IP address.
@@ -128,6 +132,7 @@
 
 	pgm_return_val_if_fail (NULL != gsi, FALSE);
 
+	{
 	int retval = gethostname (hostname, sizeof(hostname));
 	if (0 != retval) {
 		const int save_errno = pgm_get_last_sock_error();
@@ -158,8 +163,11 @@
  */
 	memcpy (gsi, &((struct sockaddr_in*)(res->ai_addr))->sin_addr, sizeof(struct in_addr));
 	freeaddrinfo (res);
+	{
 	const uint16_t random_val = pgm_random_int_range (0, UINT16_MAX);
 	memcpy ((uint8_t*)gsi + sizeof(struct in_addr), &random_val, sizeof(random_val));
+	}
+	}
 	return TRUE;
 }
 
